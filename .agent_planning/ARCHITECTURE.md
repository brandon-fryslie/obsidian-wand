# Architecture Document: Obsidian Tool-Calling Agent

**Version**: 1.0
**Date**: 2025-12-16
**Status**: Active

---

## Table of Contents

1. [System Overview](#system-overview)
2. [Component Architecture](#component-architecture)
3. [Data Flow](#data-flow)
4. [State Management](#state-management)
5. [Error Handling](#error-handling)
6. [Security & Sandboxing](#security--sandboxing)
7. [Testing Strategy](#testing-strategy)
8. [Deployment Model](#deployment-model)

---

## System Overview

### Architectural Pattern

The plugin follows a **three-layer architecture** with **event-driven communication**:

1. **Presentation Layer** (Svelte Components)
   - User interface and interaction
   - Reactive to store changes
   - Emits user events (input, approval, cancellation)

2. **Service Layer** (TypeScript Services)
   - Business logic and orchestration
   - Manages state via Svelte stores
   - No direct DOM manipulation

3. **Infrastructure Layer** (Tools + APIs)
   - Direct integration with Obsidian APIs
   - Tool implementations with schemas
   - External API calls (LLM, community plugins)

### Key Design Principles

1. **Separation of Concerns**: LLM planning completely separate from deterministic execution
2. **Type Safety**: TypeScript + Zod for compile-time and runtime validation
3. **Testability**: Each component testable in isolation with clear interfaces
4. **User Control**: Explicit confirmation required, transparent previews
5. **Fail-Safe**: Defensive validation at every boundary (user input, LLM output, tool dispatch)

---

## Component Architecture

### 1. Plugin Main (`src/main.ts`)

**Purpose**: Obsidian plugin lifecycle and initialization

**Responsibilities**:
- Extend `Plugin` class from Obsidian API
- Load/save settings (`data.json`)
- Register chat view (`VIEW_TYPE_CHAT`)
- Register ribbon icon
- Register command palette commands
- Initialize all services with `app` reference
- Cleanup on plugin unload

**Interface**:
```typescript
class ToolAgentPlugin extends Plugin {
  settings: PluginSettings;
  services: PluginServices;
  
  onload(): Promise<void>;
  onunload(): void;
  loadSettings(): Promise<PluginSettings>;
  saveSettings(): Promise<void>;
}
```

**Dependencies**:
- Obsidian Plugin API (`Plugin`, `addRibbonIcon`, `registerView`)
- PluginServices (service container)

**Testing**:
- Mock Obsidian Plugin API
- Test settings load/save
- Test view registration
- Test command registration

---

### 2. Chat View (`src/views/ChatView.ts`)

**Purpose**: Obsidian ItemView implementation that hosts Svelte components

**Responsibilities**:
- Extend `ItemView` to create custom view
- Mount Svelte root component (`ChatPanel.svelte`)
- Provide view metadata (icon, display text)
- Handle view cleanup

**Interface**:
```typescript
class ChatView extends ItemView {
  component: ChatPanel;
  services: PluginServices;
  
  getViewType(): string;
  getDisplayText(): string;
  getIcon(): string;
  onOpen(): Promise<void>;
  onClose(): Promise<void>;
}
```

**Dependencies**:
- Obsidian `ItemView`
- Svelte `ChatPanel` component
- PluginServices

**Testing**:
- Test view lifecycle (open/close)
- Test Svelte component mounting
- Mock ItemView API

---

### 3. Svelte Components (`src/components/`)

#### 3.1 ChatPanel.svelte

**Purpose**: Root component managing overall chat UI

**Responsibilities**:
- Render message input area
- Render message list
- Render plan preview (when plan available)
- Render execution progress (when executing)
- Handle user input submission
- Subscribe to conversation store

**Props**:
```typescript
{
  services: PluginServices
}
```

**State** (from stores):
- `$conversationStore` - message history
- `$planStore` - current plan awaiting approval
- `$executionStateStore` - execution status

**Events**:
- `onSubmit(message: string)` → ChatController
- `onApprove()` → ChatController
- `onCancel()` → ChatController

---

#### 3.2 MessageList.svelte

**Purpose**: Render conversation transcript

**Responsibilities**:
- Display user and assistant messages
- Auto-scroll to bottom on new messages
- Show typing indicator during streaming
- Handle message timestamps

**Props**:
```typescript
{
  messages: Message[]
}
```

---

#### 3.3 PlanPreview.svelte

**Purpose**: Display human-readable plan summary for confirmation

**Responsibilities**:
- Render plan goal and assumptions
- List files to be created/modified/deleted
- Show commands to be executed
- Display risk level badge
- Provide approve/cancel/edit buttons

**Props**:
```typescript
{
  plan: ActionPlan
  summary: PlanSummary
  onApprove: () => void
  onCancel: () => void
}
```

**Plan Summary** (generated by validator):
```typescript
interface PlanSummary {
  filesCreated: string[];
  filesModified: string[];
  filesDeleted: string[];
  foldersCreated: string[];
  commandsExecuted: string[];
  riskLevel: 'read-only' | 'writes' | 'commands';
  estimatedSteps: number;
}
```

---

#### 3.4 ExecutionProgress.svelte

**Purpose**: Show real-time execution progress

**Responsibilities**:
- Progress bar (steps completed / total)
- Current step preview
- Step-by-step log (completed steps)
- Cancel button
- Estimated time remaining (optional)

**Props**:
```typescript
{
  executionState: ExecutionState
  onCancel: () => void
}
```

---

#### 3.5 ExecutionResults.svelte

**Purpose**: Display final execution results

**Responsibilities**:
- Success/failure summary
- Files created/modified list with links
- Errors encountered (if any)
- "Save as Macro" button (on success)
- "Undo Last Run" button (if available)

**Props**:
```typescript
{
  result: ExecutionResult
  onSaveMacro: () => void
  onUndo: () => void
}
```

---

### 4. Chat Controller (`src/services/ChatController.ts`)

**Purpose**: Orchestrate conversation flow and coordinate services

**Responsibilities**:
- Manage conversation state (messages)
- Gather context snapshot (selection, active file)
- Call Planner service for plan generation
- Call Plan Validator for validation
- Trigger Executor for execution
- Update stores at each step
- Handle errors and user cancellations

**Interface**:
```typescript
class ChatController {
  constructor(
    app: App,
    settings: PluginSettings,
    llmProvider: LLMProvider,
    planner: Planner,
    validator: PlanValidator,
    executor: Executor
  );
  
  async handleUserMessage(message: string): Promise<void>;
  async handlePlanApproval(): Promise<void>;
  handlePlanRejection(): void;
  handleExecutionCancel(): void;
  
  // Store management
  conversationStore: Writable<Message[]>;
  planStore: Writable<ActionPlan | null>;
  executionStateStore: Writable<ExecutionState>;
}
```

**Flow**:
```
User Message
  → Gather context
  → Call Planner
  → Stream tokens (update conversation store)
  → Parse JSON
  → Validate plan
  → Update plan store (triggers PlanPreview)
  
User Approves
  → Call Executor
  → Update execution store (triggers ExecutionProgress)
  → Handle completion/errors
  → Update conversation store
```

**Dependencies**:
- Obsidian App (for context gathering)
- LLMProvider, Planner, PlanValidator, Executor

**Testing**:
- Mock all service dependencies
- Test conversation flow
- Test error handling
- Test store updates

---

### 5. LLM Provider (`src/services/LLMProvider.ts`)

**Purpose**: Abstract LLM API calls across providers

**Responsibilities**:
- Support OpenAI, Anthropic, custom endpoints
- Handle streaming and non-streaming
- Manage API keys (from settings)
- Normalize responses to common format
- Handle rate limits and retries
- Report token usage

**Interface**:
```typescript
interface LLMProvider {
  generateCompletion(params: CompletionParams): Promise<CompletionResult>;
  streamCompletion(
    params: CompletionParams,
    onToken: (token: string) => void
  ): Promise<CompletionResult>;
}

interface CompletionParams {
  model: string;
  systemPrompt: string;
  userMessage: string;
  temperature?: number;
  maxTokens?: number;
}

interface CompletionResult {
  content: string;
  usage: { promptTokens: number; completionTokens: number };
  finishReason: 'stop' | 'length' | 'error';
}
```

**Implementations**:
- `OpenAIProvider` - OpenAI API (GPT-4, GPT-3.5)
- `AnthropicProvider` - Anthropic API (Claude 3)
- `CustomProvider` - OpenAI-compatible endpoints

**Testing**:
- Mock API calls with fixtures
- Test streaming token handling
- Test error handling (network, rate limits)
- Test token counting

---

### 6. Planner (`src/services/Planner.ts`)

**Purpose**: Generate ActionPlan from user request

**Responsibilities**:
- Assemble system prompt with tool schemas
- Gather context (selection, active file, commands)
- Call LLM provider
- Parse streaming JSON response
- Retry on invalid JSON (max 2 attempts)

**Interface**:
```typescript
class Planner {
  constructor(
    app: App,
    llmProvider: LLMProvider,
    toolRegistry: ToolRegistry
  );
  
  async generatePlan(
    userMessage: string,
    context: PlanningContext,
    onToken?: (token: string) => void
  ): Promise<ActionPlan>;
}

interface PlanningContext {
  activeFilePath?: string;
  selection?: { text: string; range: EditorRange };
  availableCommands?: CommandDescriptor[];
  vaultConstraints: { root: string; denyPatterns: string[] };
}
```

**System Prompt Assembly**:
1. Agent instruction (from `PROJECT_SPEC/agent_prompt.md`)
2. ActionPlan JSON schema (Zod → JSON Schema)
3. Tool registry (all tool schemas)
4. Vault constraints (sandboxing rules)
5. Context snapshot
6. User message

**JSON Parsing**:
- Handle streaming tokens (`onToken` callback)
- Accumulate into buffer
- Detect JSON boundaries (`{` ... `}`)
- Parse with JSON.parse
- Retry on parse error (up to 2 times)

**Testing**:
- Mock LLM provider with fixture responses
- Test JSON parsing (valid, invalid, partial)
- Test retry logic
- Test context assembly

---

### 7. Plan Validator (`src/services/PlanValidator.ts`)

**Purpose**: Validate ActionPlan before execution

**Responsibilities**:
- Validate JSON structure against ActionPlan schema (Zod)
- Verify all tools exist in registry
- Validate tool arguments against tool schemas
- Check path sandboxing (no `..`, no absolute paths)
- Verify risk level matches operations
- Generate human-readable plan summary

**Interface**:
```typescript
class PlanValidator {
  constructor(toolRegistry: ToolRegistry, vaultRoot: string);
  
  validate(plan: ActionPlan): ValidationResult;
}

interface ValidationResult {
  valid: boolean;
  errors: ValidationError[];
  summary: PlanSummary;
}

interface ValidationError {
  code: string;
  message: string;
  stepId?: string;
  path?: string;
}
```

**Validation Steps**:
1. **Schema Validation**: `ActionPlanSchema.parse(plan)` (Zod)
2. **Tool Existence**: Check each `step.tool` exists in registry
3. **Tool Arguments**: Validate `step.args` against tool's input schema
4. **Path Sandboxing**: For vault tools, ensure all paths:
   - Are relative (not absolute)
   - Don't contain `..`
   - Don't contain `://` (URL schemes)
   - Are within vault root
5. **Risk Level**: Verify matches actual operations (reads vs writes vs commands)
6. **Foreach References**: Verify `foreach.from` references valid step output

**Summary Generation**:
- Analyze steps to extract:
  - Files to be created (`vault.createFile`)
  - Files to be modified (`vault.writeFile`, `editor.replaceSelection`)
  - Files to be deleted (`vault.delete`)
  - Folders to be created (`vault.ensureFolder`)
  - Commands to be executed (`commands.run`)

**Testing**:
- Test with valid plans (should pass)
- Test with invalid schemas (should fail with clear errors)
- Test path traversal attempts (should block)
- Test tool allowlist (should reject unknown tools)

---

### 8. Executor (`src/services/Executor.ts`)

**Purpose**: Execute validated ActionPlan deterministically

**Responsibilities**:
- Resolve step dependencies (`dependsOn`)
- Expand foreach loops
- Schedule steps in correct order
- Dispatch tool calls to tool registry
- Handle retries (per step config)
- Track progress
- Support cancellation mid-execution
- Maintain undo journal

**Interface**:
```typescript
class Executor {
  constructor(
    app: App,
    toolRegistry: ToolRegistry,
    settings: PluginSettings
  );
  
  async execute(
    plan: ActionPlan,
    onProgress: (event: ExecutionEvent) => void
  ): Promise<ExecutionResult>;
  
  cancel(): void;
  undo(): Promise<UndoResult>;
}

interface ExecutionResult {
  success: boolean;
  completedSteps: number;
  totalSteps: number;
  outputs: Record<string, any>;
  errors: ExecutionError[];
  effects: EffectsSummary;
  undoAvailable: boolean;
}
```

**Execution Algorithm**:

```typescript
async function execute(plan: ActionPlan): ExecutionResult {
  // 1. Build dependency graph
  const graph = buildDependencyGraph(plan.steps);
  
  // 2. Topological sort for execution order
  const order = topologicalSort(graph);
  
  // 3. Initialize runtime context
  const context = new ExecutionContext();
  context.set('$vars.vaultRoot', app.vault.getRoot().path);
  
  // 4. Execute steps in order
  for (const stepId of order) {
    if (cancelled) break;
    
    const step = plan.steps.find(s => s.id === stepId);
    
    // 4a. Expand foreach if present
    const instances = step.foreach 
      ? expandForEach(step, context) 
      : [step];
    
    // 4b. Execute each instance
    for (const instance of instances) {
      // Resolve args (replace $refs with runtime values)
      const resolvedArgs = resolveArgs(instance.args, context);
      
      // Dispatch to tool
      const result = await dispatchTool(
        instance.tool,
        resolvedArgs,
        instance.retry
      );
      
      // Handle result
      if (result.ok) {
        // Store output in context
        context.set(`$steps.${stepId}`, result.data);
        if (instance.captureAs) {
          context.set(`$vars.${instance.captureAs}`, result.data);
        }
        
        // Track effects for undo
        undoJournal.record(result.effects);
        
        // Emit progress
        onProgress({ type: 'step.finished', stepId, result });
      } else {
        // Handle error per onError strategy
        switch (instance.onError || plan.defaults?.onError || 'stop') {
          case 'stop':
            throw new ExecutionError(stepId, result.error);
          case 'skip':
            onProgress({ type: 'step.skipped', stepId, result });
            continue;
          case 'retry':
            // Already handled by dispatchTool retry logic
            break;
        }
      }
    }
  }
  
  return buildExecutionResult(context, undoJournal);
}
```

**Foreach Expansion**:
```typescript
function expandForEach(step: Step, context: ExecutionContext): Step[] {
  const array = context.get(step.foreach.from);
  if (!Array.isArray(array)) {
    throw new Error(`foreach.from is not an array: ${step.foreach.from}`);
  }
  
  return array.map((item, index) => ({
    ...step,
    id: `${step.id}_${index}`,
    args: resolveArgs(step.args, {
      ...context,
      [step.foreach.itemName]: item,
      [step.foreach.indexName || 'index']: index
    })
  }));
}
```

**Retry Logic**:
```typescript
async function dispatchTool(
  toolName: string,
  args: any,
  retry?: RetryPolicy
): Promise<ToolResult> {
  const maxAttempts = retry?.maxAttempts || 1;
  const backoffMs = retry?.backoffMs || 250;
  
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    const result = await toolRegistry.execute(toolName, args);
    
    if (result.ok || !result.error?.retryable) {
      return result;
    }
    
    if (attempt < maxAttempts) {
      await sleep(backoffMs * attempt); // Exponential backoff
    }
  }
  
  return result; // Return last result (error)
}
```

**Undo Journal**:
- Track all write operations:
  - `vault.createFile`: Store file path (for deletion)
  - `vault.writeFile`: Store previous content (for restore)
  - `vault.delete`: Store deleted file content (for restore from trash)
  - `vault.rename`: Store old path (for rename back)
  - `editor.replaceSelection`: Store previous selection (for restore)
- Limit: Last run only (not full history)
- Best-effort: Some operations can't be undone (commands)

**Testing**:
- Test sequential execution
- Test dependency resolution (dependsOn)
- Test foreach expansion
- Test retry logic
- Test cancellation
- Test undo functionality
- Test error handling (stop/skip)

---

### 9. Tool Registry (`src/services/ToolRegistry.ts`)

**Purpose**: Central registry of all tools with schemas

**Responsibilities**:
- Register tools with schemas
- Dispatch tool calls
- Validate tool arguments (input schema)
- Validate tool results (output schema)
- Normalize results to ToolResult envelope
- Track tool metadata (risk level, category)

**Interface**:
```typescript
class ToolRegistry {
  constructor(app: App);
  
  register(toolDef: ToolDefinition): void;
  has(toolName: string): boolean;
  execute(toolName: string, args: any): Promise<ToolResult>;
  getSchema(toolName: string): ToolSchema;
  getAllTools(): ToolDefinition[];
}

interface ToolDefinition {
  name: string;
  category: 'vault' | 'editor' | 'workspace' | 'commands' | 'util';
  description: string;
  riskLevel: 'read-only' | 'writes' | 'commands';
  inputSchema: ZodSchema;
  outputSchema: ZodSchema;
  execute: (app: App, args: any) => Promise<any>;
}
```

**Execution Flow**:
```typescript
async execute(toolName: string, args: any): Promise<ToolResult> {
  const tool = this.tools.get(toolName);
  if (!tool) {
    return ToolResult.error('TOOL_NOT_FOUND', `Tool not found: ${toolName}`);
  }
  
  // 1. Validate input
  try {
    tool.inputSchema.parse(args);
  } catch (err) {
    return ToolResult.error('VALIDATION_ERROR', err.message);
  }
  
  // 2. Execute tool
  const startTime = Date.now();
  let result;
  try {
    result = await tool.execute(this.app, args);
  } catch (err) {
    return ToolResult.error('INTERNAL_ERROR', err.message, {
      durationMs: Date.now() - startTime
    });
  }
  
  // 3. Validate output
  try {
    tool.outputSchema.parse(result);
  } catch (err) {
    return ToolResult.error('OUTPUT_VALIDATION_ERROR', err.message);
  }
  
  // 4. Return normalized result
  return ToolResult.success(result, {
    tool: toolName,
    durationMs: Date.now() - startTime
  });
}
```

**Testing**:
- Test tool registration
- Test input validation
- Test output validation
- Test error handling
- Mock Obsidian app for tool execution tests

---

### 10. Tools Layer (`src/tools/`)

Individual tool implementations. Each tool is a function conforming to:

```typescript
type ToolFunction = (app: App, args: ToolArgs) => Promise<ToolOutput>;
```

#### Tool Structure

**src/tools/vault/**:
- `ensureFolder.ts`
- `createFile.ts`
- `readFile.ts`
- `writeFile.ts`
- `rename.ts`
- `delete.ts`
- `searchText.ts`
- `listFiles.ts`

**src/tools/editor/**:
- `getSelection.ts`
- `replaceSelection.ts`
- `insertAtCursor.ts`
- `getActiveFilePath.ts`

**src/tools/workspace/**:
- `openFile.ts`
- `getContext.ts`

**src/tools/commands/**:
- `listCommands.ts`
- `runCommand.ts`

**src/tools/util/**:
- `parseMarkdownBullets.ts`
- `slugifyTitle.ts`

#### Example Tool: vault.createFile

```typescript
// src/tools/vault/createFile.ts
import { z } from 'zod';
import { App, TFile } from 'obsidian';

export const createFileInputSchema = z.object({
  path: z.string().min(1),
  content: z.string(),
  ifNotExists: z.boolean().optional(),
  frontmatter: z.record(z.any()).optional()
});

export const createFileOutputSchema = z.object({
  path: z.string(),
  created: z.boolean(),
  etag: z.string().optional(),
  mtimeMs: z.number().optional()
});

export async function createFile(
  app: App,
  args: z.infer<typeof createFileInputSchema>
): Promise<z.infer<typeof createFileOutputSchema>> {
  // 1. Normalize path
  const normalizedPath = normalizePath(args.path);
  
  // 2. Check if exists (if ifNotExists)
  if (args.ifNotExists && await app.vault.adapter.exists(normalizedPath)) {
    return {
      path: normalizedPath,
      created: false
    };
  }
  
  // 3. Build content with frontmatter if provided
  let content = args.content;
  if (args.frontmatter) {
    const fm = Object.entries(args.frontmatter)
      .map(([k, v]) => `${k}: ${JSON.stringify(v)}`)
      .join('\n');
    content = `---\n${fm}\n---\n\n${args.content}`;
  }
  
  // 4. Create file using Vault API
  const file = await app.vault.create(normalizedPath, content);
  
  // 5. Return result
  return {
    path: file.path,
    created: true,
    mtimeMs: file.stat.mtime
  };
}

export const createFileTool: ToolDefinition = {
  name: 'vault.createFile',
  category: 'vault',
  description: 'Create a new file in the vault',
  riskLevel: 'writes',
  inputSchema: createFileInputSchema,
  outputSchema: createFileOutputSchema,
  execute: createFile
};
```

**Testing**:
- Mock Obsidian Vault API
- Test file creation
- Test collision handling
- Test frontmatter injection
- Test path normalization

---

### 11. Macro Store (`src/services/MacroStore.ts`)

**Purpose**: Save and execute plans offline

**Responsibilities**:
- Save ActionPlan as named macro
- Support parameter templates (`${param}`)
- Bind runtime context to parameters
- Execute macros via Executor (no LLM)
- Persist macros in plugin data
- Register macros as commands

**Interface**:
```typescript
class MacroStore {
  constructor(
    plugin: Plugin,
    executor: Executor
  );
  
  async saveMacro(name: string, plan: ActionPlan): Promise<SavedMacro>;
  async executeMacro(id: string, context: RuntimeContext): Promise<ExecutionResult>;
  listMacros(): SavedMacro[];
  deleteMacro(id: string): Promise<void>;
  exportMacro(id: string): string; // JSON
  importMacro(json: string): Promise<SavedMacro>;
}

interface SavedMacro {
  id: string;
  name: string;
  description?: string;
  plan: ActionPlan;
  parameters: string[]; // Extracted from plan (${param} references)
  createdAt: number;
  usageCount: number;
}
```

**Parameter Extraction**:
```typescript
function extractParameters(plan: ActionPlan): string[] {
  const params = new Set<string>();
  const regex = /\$\{([a-zA-Z][a-zA-Z0-9_]*)\}/g;
  
  JSON.stringify(plan).replace(regex, (_, param) => {
    params.add(param);
    return '';
  });
  
  return Array.from(params);
}
```

**Parameter Binding**:
```typescript
function bindParameters(plan: ActionPlan, context: RuntimeContext): ActionPlan {
  const json = JSON.stringify(plan);
  const bound = json.replace(/\$\{([a-zA-Z][a-zA-Z0-9_]*)\}/g, (match, param) => {
    const value = context[param];
    if (value === undefined) {
      throw new Error(`Missing parameter: ${param}`);
    }
    return JSON.stringify(value);
  });
  
  return JSON.parse(bound);
}
```

**Command Registration**:
```typescript
async saveMacro(name: string, plan: ActionPlan): Promise<SavedMacro> {
  const macro = {
    id: nanoid(),
    name,
    plan,
    parameters: extractParameters(plan),
    createdAt: Date.now(),
    usageCount: 0
  };
  
  this.macros.set(macro.id, macro);
  await this.persist();
  
  // Register command
  this.plugin.addCommand({
    id: `run-macro-${macro.id}`,
    name: `Run: ${name}`,
    callback: () => this.executeMacro(macro.id, this.gatherContext())
  });
  
  return macro;
}
```

**Testing**:
- Test macro save/load
- Test parameter extraction
- Test parameter binding
- Test command registration
- Test execution without LLM

---

### 12. Community Plugin Index (`src/services/PluginIndex.ts`)

**Purpose**: Provide plugin recommendations

**Responsibilities**:
- Fetch community-plugins.json
- Cache locally (refresh daily)
- Search plugins by keyword
- Return plugin metadata
- Never install plugins

**Interface**:
```typescript
class PluginIndex {
  constructor(app: App);
  
  async fetchIndex(): Promise<void>;
  search(query: string, limit?: number): PluginMatch[];
  get(id: string): CommunityPlugin | undefined;
}

interface CommunityPlugin {
  id: string;
  name: string;
  author: string;
  description: string;
  repo: string;
}

interface PluginMatch {
  plugin: CommunityPlugin;
  score: number;
}
```

**Implementation**:
- Use Obsidian `requestUrl` to fetch JSON
- Use `fuse.js` for fuzzy search
- Cache in memory + localStorage (expires 24h)

**Testing**:
- Mock requestUrl
- Test search ranking
- Test cache expiration

---

## Data Flow

### Complete User Flow Example

**Scenario**: User wants to create notes from selected bullet points

```
1. USER SELECTS TEXT IN EDITOR
   - 10 bullet points selected
   - Active file: "Daily/2025-12-16.md"

2. USER TYPES MESSAGE
   - "Create a note for each bullet in folder 'Projects'"
   - Clicks "Run" button

3. CHAT PANEL → CHAT CONTROLLER
   - ChatPanel.onSubmit(message)
   - ChatController.handleUserMessage(message)

4. CHAT CONTROLLER GATHERS CONTEXT
   - Get active file: app.workspace.getActiveFile()
   - Get selection: app.workspace.activeEditor.editor.getSelection()
   - Get vault root: app.vault.getRoot().path
   - Get available tools: toolRegistry.getAllTools()
   
   Context:
   {
     activeFilePath: "Daily/2025-12-16.md",
     selection: {
       text: "- Project A\n- Project B\n...",
       range: { from: {line: 5, ch: 0}, to: {line: 14, ch: 15} }
     },
     vaultConstraints: {
       root: "/",
       denyPatterns: ["..", "://"]
     }
   }

5. CHAT CONTROLLER → PLANNER
   - Planner.generatePlan(message, context, onToken)

6. PLANNER ASSEMBLES PROMPT
   System:
   - Agent instruction (from agent_prompt.md)
   - ActionPlan JSON schema
   - Tool schemas (all 25+ tools)
   - Vault constraints
   
   User:
   - Context: active file, selection (first 500 chars)
   - Message: "Create a note for each bullet in folder 'Projects'"

7. PLANNER → LLM PROVIDER
   - LLMProvider.streamCompletion(params, onToken)

8. LLM PROVIDER → OPENAI API
   - POST https://api.openai.com/v1/chat/completions
   - model: "gpt-4"
   - messages: [system, user]
   - stream: true

9. OPENAI API → LLM PROVIDER (STREAMING)
   - Tokens: {, "version", :, "1.0", ...
   - Accumulated into buffer

10. LLM PROVIDER → PLANNER (STREAMING)
    - onToken("{")
    - onToken("\"version\"")
    - ...

11. PLANNER → CHAT CONTROLLER (STREAMING)
    - onToken callback updates conversation store
    - User sees typing indicator with streaming JSON

12. PLANNER PARSES COMPLETE JSON
    - Buffer: "{\"version\":\"1.0\",\"goal\":\"Create notes...\"...}"
    - JSON.parse() → ActionPlan object

13. PLANNER VALIDATES JSON STRUCTURE
    - ActionPlanSchema.parse(plan) ✓

14. PLANNER → CHAT CONTROLLER (PLAN READY)
    - Returns ActionPlan object

15. CHAT CONTROLLER → PLAN VALIDATOR
    - PlanValidator.validate(plan)

16. PLAN VALIDATOR VALIDATES
    - Schema: ✓
    - Tools exist: ✓ (vault.ensureFolder, util.parseMarkdownBullets, vault.createFile, editor.replaceSelection)
    - Tool args: ✓ (all args match schemas)
    - Path sandboxing: ✓ (all paths start with "Projects/")
    - Risk level: ✓ ("writes" matches file creation)

17. PLAN VALIDATOR GENERATES SUMMARY
    {
      filesCreated: ["Projects/Project A.md", "Projects/Project B.md", ...],
      filesModified: ["Daily/2025-12-16.md"],
      filesDeleted: [],
      foldersCreated: ["Projects"],
      commandsExecuted: [],
      riskLevel: "writes",
      estimatedSteps: 13
    }

18. PLAN VALIDATOR → CHAT CONTROLLER (VALIDATION RESULT)
    - Valid: true
    - Summary: {...}

19. CHAT CONTROLLER UPDATES STORES
    - planStore.set(plan)
    - conversationStore.update(msgs => [...msgs, {role: 'assistant', plan}])

20. SVELTE REACTIVITY → CHAT PANEL
    - $planStore updated
    - PlanPreview component appears

21. USER REVIEWS PLAN
    - Sees: "Will create 10 files, modify 1 file"
    - Risk level: "writes"
    - List of files to create
    - Clicks "Approve"

22. CHAT PANEL → CHAT CONTROLLER
    - ChatPanel.onApprove()
    - ChatController.handlePlanApproval()

23. CHAT CONTROLLER → EXECUTOR
    - Executor.execute(plan, onProgress)

24. EXECUTOR BUILDS DEPENDENCY GRAPH
    - Steps: [ensureFolder, parseBullets, createFile (foreach), replaceSelection]
    - Dependencies: createFile dependsOn parseBullets

25. EXECUTOR EXECUTES STEPS
    
    Step 1: vault.ensureFolder({path: "Projects"})
    - ToolRegistry.execute("vault.ensureFolder", {path: "Projects"})
    - Tool validates args ✓
    - Tool executes: app.vault.createFolder("Projects")
    - Tool returns: {path: "Projects", created: true}
    - Context: $steps.ensureFolder = {path: "Projects", created: true}
    - onProgress({type: 'step.finished', stepId: 'ensureFolder'})
    
    Step 2: util.parseMarkdownBullets({text: selection})
    - ToolRegistry.execute("util.parseMarkdownBullets", {text: "- Project A\n..."})
    - Tool parses: [{text: "Project A", raw: "- Project A", depth: 0}, ...]
    - Tool returns: {items: [...], count: 10}
    - Context: $steps.parseBullets = {items: [...], count: 10}
    - onProgress({type: 'step.finished', stepId: 'parseBullets'})
    
    Step 3: vault.createFile (foreach expansion)
    - Foreach: {from: "$steps.parseBullets.items", itemName: "item"}
    - Resolve reference: context.get("$steps.parseBullets.items") → array of 10
    - Expand into 10 step instances
    
    Step 3.0: vault.createFile({path: "Projects/Project A.md", content: "..."})
    - Args resolved: {item.text} → "Project A"
    - ToolRegistry.execute(...)
    - Tool creates file
    - Returns: {path: "Projects/Project A.md", created: true, mtimeMs: ...}
    - UndoJournal.record({created: ["Projects/Project A.md"]})
    - onProgress({type: 'step.finished', stepId: 'createNote_0'})
    
    Step 3.1-3.9: (same for remaining bullets)
    
    Step 4: editor.replaceSelection({text: "[[Projects/Project A]]..."})
    - ToolRegistry.execute(...)
    - Tool: app.workspace.activeEditor.editor.replaceSelection(text)
    - Returns: {filePath: "Daily/2025-12-16.md", range: {...}, insertedChars: 250}
    - UndoJournal.record({modified: [{path: "Daily/2025-12-16.md", before: "..."}]})
    - onProgress({type: 'step.finished', stepId: 'replaceSelection'})

26. EXECUTOR → CHAT CONTROLLER (EXECUTION COMPLETE)
    - ExecutionResult: {success: true, completedSteps: 13, totalSteps: 13, ...}

27. CHAT CONTROLLER UPDATES STORES
    - executionStateStore.set({status: 'completed', result: ...})
    - conversationStore.update(msgs => [...msgs, {role: 'system', type: 'execution-result', result}])

28. SVELTE REACTIVITY → EXECUTION RESULTS
    - ExecutionResults component appears
    - Shows: "Created 10 files, modified 1 file"
    - Links to created files
    - "Save as Macro" button

29. USER CLICKS "SAVE AS MACRO"
    - ExecutionResults.onSaveMacro()
    - ChatController → MacroStore

30. MACRO STORE SAVES PLAN
    - Extract parameters: ["selection", "folderName"]
    - Save macro: {id: "abc123", name: "Create notes from bullets", plan: ...}
    - Register command: "Run: Create notes from bullets"
    - Persist to data.json

31. FUTURE: USER RUNS MACRO
    - Select new bullets
    - Command palette: "Run: Create notes from bullets"
    - MacroStore.executeMacro(id, context)
    - Bind parameters: ${selection} → current selection
    - Executor.execute(boundPlan, onProgress)
    - No LLM call!
```

---

## State Management

### Svelte Stores

**conversationStore** (`writable<Message[]>`):
```typescript
interface Message {
  role: 'user' | 'assistant' | 'system';
  content?: string;
  plan?: ActionPlan;
  result?: ExecutionResult;
  timestamp: number;
}
```

**planStore** (`writable<ActionPlan | null>`):
- Current plan awaiting user approval
- Set by Chat Controller after validation
- Cleared after approval/rejection

**executionStateStore** (`writable<ExecutionState>`):
```typescript
interface ExecutionState {
  status: 'idle' | 'executing' | 'completed' | 'error' | 'cancelled';
  currentStep?: number;
  totalSteps?: number;
  currentStepPreview?: string;
  completedSteps: StepResult[];
  result?: ExecutionResult;
}
```

**settingsStore** (`writable<PluginSettings>`):
```typescript
interface PluginSettings {
  llmProvider: 'openai' | 'anthropic' | 'custom';
  apiKey: string;
  model: string;
  temperature: number;
  maxTokens: number;
  streaming: boolean;
  customEndpoint?: string;
  confirmWrites: boolean;
  confirmCommands: boolean;
  allowDeletes: boolean;
  autoApproveReadOnly: boolean;
}
```

**macrosStore** (`writable<SavedMacro[]>`):
- List of all saved macros
- Updated by MacroStore
- Drives macro list UI

---

## Error Handling

### Error Classification

**User Errors** (recoverable, show in UI):
- Invalid input (empty message, missing selection when required)
- Rejection of plan
- Cancellation mid-execution

**LLM Errors** (may retry):
- Invalid JSON response
- Schema validation failure
- Rate limiting

**Tool Errors** (show in execution log):
- File not found
- Permission denied
- Path sandboxing violation
- Command not found

**System Errors** (report to user, log for debugging):
- Network failure
- Obsidian API crash
- Unexpected exceptions

### Error Handling Strategy

1. **Validation Errors** → User feedback
   - Clear message: "Selection is empty. Please select text first."
   - Suggest action: "Select bullet points to create notes from"

2. **LLM Errors** → Retry with backoff
   - Attempt 1: Parse JSON
   - Attempt 2: Retry with clarified prompt ("Output ONLY valid JSON")
   - Attempt 3: Fail with message: "LLM failed to generate valid plan. Try rephrasing your request."

3. **Tool Errors** → Per-step handling
   - onError: "stop" → Halt execution, show error
   - onError: "skip" → Log warning, continue with next step
   - onError: "retry" → Retry with backoff (up to maxAttempts)

4. **System Errors** → Graceful degradation
   - Log full stack trace to console
   - Show user-friendly message: "An unexpected error occurred. Please try again."
   - Offer "Report Issue" button (copies error to clipboard)

---

## Security & Sandboxing

### Path Sandboxing

**Rules**:
1. All paths must be relative (no leading `/`)
2. No path traversal (`..` disallowed)
3. No URL schemes (`://` disallowed)
4. All paths normalized (redundant slashes removed)

**Validation**:
```typescript
function validatePath(path: string, vaultRoot: string): ValidationResult {
  // 1. Check for absolute path
  if (path.startsWith('/') || /^[A-Z]:\\/.test(path)) {
    return {valid: false, error: 'Absolute paths not allowed'};
  }
  
  // 2. Check for path traversal
  if (path.includes('..')) {
    return {valid: false, error: 'Path traversal (..) not allowed'};
  }
  
  // 3. Check for URL scheme
  if (path.includes('://')) {
    return {valid: false, error: 'URL schemes not allowed'};
  }
  
  // 4. Normalize and verify within vault
  const normalized = normalizePath(path);
  const fullPath = join(vaultRoot, normalized);
  if (!fullPath.startsWith(vaultRoot)) {
    return {valid: false, error: 'Path outside vault'};
  }
  
  return {valid: true, normalized};
}
```

### API Key Security

**Storage**:
- API keys stored in plugin `data.json` (encrypted by Obsidian)
- Never logged to console
- Never included in error messages
- Never sent except to configured LLM provider

**Usage**:
- Only used in LLM Provider service
- Transmitted over HTTPS only
- Not exposed to tool implementations

### Command Execution Safety

**Precautions**:
- No arbitrary code execution (only registered commands)
- Command IDs validated against available commands
- Failures handled gracefully (no crashes)
- Document as "best-effort" (may break if commands change)

---

## Testing Strategy

### Unit Tests (Jest)

**Coverage goal**: 90% for core services, 100% for tools

**Test structure**:
```
tests/
  unit/
    tools/
      vault/
        createFile.test.ts
        readFile.test.ts
        ...
      editor/
        getSelection.test.ts
        ...
    services/
      ChatController.test.ts
      Planner.test.ts
      Executor.test.ts
      ...
    schemas/
      ActionPlan.test.ts
      ToolSchemas.test.ts
```

**Mocking strategy**:
- Mock Obsidian API (`app.vault`, `app.workspace`, `app.commands`)
- Mock LLM Provider (return fixture plans)
- Use real Zod validation (don't mock schemas)

### Integration Tests (Jest)

**Focus**: Multi-component flows

**Examples**:
- Executor + Tools (execute complex plan)
- Planner + Validator (validate LLM output)
- MacroStore + Executor (execute macro offline)

### E2E Tests (Playwright)

**Setup**:
- Launch Obsidian in test mode
- Install plugin automatically
- Create test vault with fixtures

**Key scenarios**:
1. Create notes from selection
2. Run saved macro
3. Cancel mid-execution
4. Handle LLM errors gracefully
5. Undo last operation

**Test structure**:
```typescript
test('create notes from bullet selection', async ({page}) => {
  // 1. Open test vault
  await page.goto('obsidian://open?vault=test-vault');
  
  // 2. Create note with bullets
  await page.click('[aria-label="New note"]');
  await page.fill('.cm-editor', '- Item 1\n- Item 2\n- Item 3');
  
  // 3. Select bullets
  await page.selectText('.cm-editor', 0, 33);
  
  // 4. Open plugin
  await page.click('[aria-label="Open Tool-Calling Agent"]');
  
  // 5. Enter message
  await page.fill('[data-testid="chat-input"]', 'Create a note for each bullet in folder "Test"');
  await page.click('[data-testid="submit"]');
  
  // 6. Wait for plan preview
  await page.waitForSelector('[data-testid="plan-preview"]');
  
  // 7. Approve plan
  await page.click('[data-testid="approve-plan"]');
  
  // 8. Wait for execution complete
  await page.waitForSelector('[data-testid="execution-complete"]');
  
  // 9. Verify files created
  const files = await page.evaluate(() => 
    app.vault.getFiles().map(f => f.path)
  );
  expect(files).toContain('Test/Item 1.md');
  expect(files).toContain('Test/Item 2.md');
  expect(files).toContain('Test/Item 3.md');
});
```

---

## Deployment Model

### Development

**Local testing**:
- Test vault: `.obsidian-test-vault/`
- Hot reload: esbuild watch mode
- Manual testing: Obsidian desktop app

**Build**:
```bash
just dev     # Development mode (watch, source maps)
just build   # Production mode (minified, no source maps)
```

### Production

**Plugin structure**:
```
.obsidian/plugins/obsidian-toolagent/
  main.js          # Bundled plugin code
  manifest.json    # Plugin metadata
  styles.css       # (optional) Plugin styles
  data.json        # Plugin settings + macros
```

**Installation**:
1. User enables community plugins
2. User browses community plugins
3. User searches "Tool-Calling Agent"
4. User clicks "Install"
5. Obsidian downloads from releases repo
6. User enables plugin
7. User configures API key in settings

**Updates**:
- Obsidian checks for updates automatically
- User sees "Update available" notification
- User clicks "Update"
- Plugin reloaded with new version

### Distribution

**Release process**:
1. Update version in `manifest.json` and `package.json`
2. Update `versions.json` with compatibility
3. Create git tag: `git tag v1.2.3`
4. Push tag: `git push --tags`
5. GitHub Actions builds release artifacts
6. Create GitHub release with `main.js`, `manifest.json`, `styles.css`
7. Submit to Obsidian community plugins (first time only)

**Versioning**:
- Semver: MAJOR.MINOR.PATCH
- MAJOR: Breaking changes (rare)
- MINOR: New features (common)
- PATCH: Bug fixes (frequent)

---

## Summary

This architecture provides:

1. **Safety**: Explicit confirmation, path sandboxing, schema validation
2. **Transparency**: Plan preview, execution progress, clear errors
3. **Flexibility**: Support multiple LLM providers, extensible tool system
4. **Reliability**: Deterministic execution, comprehensive testing, error handling
5. **Usability**: Reactive UI, offline macros, clear documentation

The three-layer architecture (Presentation → Service → Infrastructure) with clear boundaries enables independent testing, iterative development, and long-term maintainability.

---

**Last Updated**: 2025-12-16
**Version**: 1.0
