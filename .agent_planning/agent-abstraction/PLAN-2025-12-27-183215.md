# Sprint Plan: Agent Abstraction Layer - Infrastructure Foundation

**Generated**: 2025-12-27-183215
**Source**: STATUS-2025-12-27-182800.md
**Sprint Goal**: Create the foundational infrastructure for multiple agent implementations without breaking existing functionality
**Sprint Type**: Refactoring (no new features)

---

## Executive Summary

### Current State
The Obsidian Tool Agent plugin currently implements a single "Wand" agent pattern hard-coded into ChatController (929 lines). The architecture tightly couples prompts, planning logic, and execution orchestration into a monolithic service. This prevents introducing alternative agent implementations (research agents, documentation agents, simple command agents) without major rewrites.

**Evidence from STATUS-2025-12-27-182800.md**:
- ChatController owns all agent responsibilities (lines 160-186)
- Settings only support LLM provider selection, no agent type concept (lines 192-218)
- System prompts hard-coded in ChatController (lines 220-239)
- No agent abstraction, interface, or registry exists (lines 101-145, 258-284)

### Gap Analysis Summary
| Dimension | Current | Target | Priority |
|-----------|---------|--------|----------|
| **Agent Interface** | None - monolithic ChatController | Abstract `Agent` interface with implementations | P0 |
| **Agent Selection** | No concept of agent types | Settings UI with agent dropdown | P0 |
| **Agent Registry** | Hard-coded instantiation in PluginServices | Factory pattern with registry | P0 |
| **Implementation** | Everything in ChatController | WandAgent implementing Agent interface | P0 |
| **Backward Compat** | N/A | Existing functionality works identically | P0 |
| **Test Coverage** | Unit tests only, no agent lifecycle tests | Integration tests for Agent interface | P1 |

### Sprint Scope (ONE SPRINT = 2-3 weeks)

**IN SCOPE** (This Sprint):
1. ✅ Define Agent interface and type system
2. ✅ Extract WandAgent from ChatController
3. ✅ Add agent type to settings with UI dropdown
4. ✅ Implement agent registry/factory pattern
5. ✅ Integration tests for backward compatibility

**OUT OF SCOPE** (Future Sprints):
- ❌ Implementing additional agent types (research, docs, command)
- ❌ Agent auto-routing or chaining
- ❌ Per-agent LLM provider configuration
- ❌ Advanced agent capabilities (learning, delegation)

**Success Criteria**:
- Existing Wand functionality works identically (100% backward compatible)
- Agent interface supports future implementations with <100 LOC per agent
- Settings UI shows agent dropdown (even if only "Wand" option exists)
- Tests pass, TypeScript compiles, no runtime regressions

---

## Backlog by Priority

### P0 (Critical) - Sprint Foundation

---

## P0-1: Define Agent Interface and Type System

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: None - foundation for everything else
**Spec Reference**: N/A (new architecture) • **Status Reference**: STATUS-2025-12-27-182800.md lines 101-145 (What's Missing: Common Agent API/Interface)

### Description
Create the abstract `Agent` interface that all agent implementations must satisfy. This interface defines the contract for agent lifecycle, message handling, state management, and capabilities. Based on STATUS ambiguity analysis (lines 373-481), we'll use Option B: Agents own prompts + planning logic, share executor.

This is pure TypeScript interface definition with no implementation - it establishes the contract that WandAgent and future agents must follow.

### Acceptance Criteria (REQUIRED)
- [ ] `src/agents/Agent.ts` exports `Agent` interface with methods: `initialize()`, `handleUserMessage()`, `cleanup()`, `getName()`, `getDescription()`, `getCapabilities()`, `getState()`, `onStateChange()`, `abort()`
- [ ] `AgentResponse` type defined with fields: `type` (plan|message|error), `content`, `requiresApproval`, `metadata`
- [ ] `AgentState` type defined with fields: `status` (idle|thinking|executing|error), `currentPlan`, `isProcessing`, `lastError`
- [ ] `AgentCapability` enum defined with values: `planning`, `execution`, `conversation`, `multi-step`, `research`
- [ ] `AgentDependencies` interface defined with common services: `app`, `settings`, `llmProvider`, `executor`, `toolsLayer`, `approvalService`
- [ ] Interface documented with JSDoc comments explaining each method's contract and lifecycle expectations
- [ ] TypeScript compiles without errors (`pnpm run typecheck`)

### Technical Notes
- **Design Decision**: Agent owns prompts and planning, shares executor (STATUS lines 373-397)
- **Manual agent selection** initially, design for future auto-routing via `canHandle()` method (STATUS lines 426-448)
- **Shared LLM provider** with future per-agent override support (STATUS lines 451-481)
- Keep interface minimal - don't over-engineer for future use cases we don't have yet (YAGNI principle)
- Consider adding optional `canHandle(message: string): Promise<boolean>` for future auto-routing, but don't implement routing logic this sprint

---

## P0-2: Extract WandAgent from ChatController

**Status**: Not Started
**Effort**: Large (1-2 weeks)
**Dependencies**: P0-1 (Agent interface must exist)
**Spec Reference**: CLAUDE.md lines 50-73 (AI Agent Architecture) • **Status Reference**: STATUS-2025-12-27-182800.md lines 158-186 (ChatController is Monolithic)

### Description
Refactor the monolithic ChatController (929 lines) into two components:
1. **WandAgent** - Concrete implementation of `Agent` interface containing Wand-specific logic (prompts, planning, placeholder resolution)
2. **ChatController** - Thin orchestrator that delegates to the selected Agent implementation

This is a large, high-risk refactor that must maintain 100% backward compatibility. Current ChatController behavior becomes the WandAgent implementation, while ChatController becomes a facade that forwards calls to the agent.

**Current ChatController responsibilities** (lines 160-186):
- Prompt building (lines 731-851) → Move to WandAgent
- Plan generation with retry (lines 523-639) → Move to WandAgent
- Placeholder resolution (lines 641-729) → Move to WandAgent
- Message formatting (lines 853-889) → Move to WandAgent
- Approval checking (lines 226-248) → Keep in ChatController (uses ApprovalService)
- Execution orchestration (lines 299-364) → Keep in ChatController (delegates to Executor)

### Acceptance Criteria (REQUIRED)
- [ ] `src/agents/WandAgent.ts` created implementing `Agent` interface with all Wand-specific logic extracted from ChatController
- [ ] WandAgent owns: `buildSystemPrompt()`, `buildUserPrompt()`, `generatePlan()`, `resolvePlaceholders()`, `formatResponse()`
- [ ] ChatController refactored to <300 lines - acts as thin orchestrator delegating to `this.currentAgent`
- [ ] ChatController.sendMessage() now calls `this.currentAgent.handleUserMessage()` instead of internal logic
- [ ] Existing message flow works identically: User Input → Agent → Plan → Approval → Execution
- [ ] All existing unit tests pass without modification (if tests fail, it indicates broken backward compatibility)
- [ ] Integration test written: "WandAgent produces identical plans to legacy ChatController for same inputs" (create test fixtures from real usage)
- [ ] TypeScript compiles without errors (`pnpm run typecheck`)
- [ ] Manual testing: Open plugin, send message "Create a daily note for today", verify plan generation and execution works as before

### Technical Notes
- **High Risk**: This touches core functionality - proceed incrementally
- **Refactoring Strategy**:
  1. Create WandAgent shell implementing Agent interface
  2. Copy (don't move) ChatController methods into WandAgent
  3. Wire ChatController to delegate to WandAgent
  4. Test extensively - every existing interaction must work
  5. Remove duplicated code from ChatController only after tests pass
- **PlanGenerator**: STATUS suggests making it Wand-specific (lines 241-257). For this sprint, keep PlanGenerator as shared service, WandAgent uses it. Future agents can use different planning strategies.
- **State Management**: ChatController currently uses callback-based state updates. WandAgent should use same pattern for consistency.
- **Error Handling**: Preserve existing `formatError()` behavior - user-facing error messages must remain unchanged

---

## P0-3: Add Agent Selection to Settings

**Status**: Not Started
**Effort**: Medium (4-5 days)
**Dependencies**: P0-1 (Agent interface), P0-2 (WandAgent exists)
**Spec Reference**: N/A (new architecture) • **Status Reference**: STATUS-2025-12-27-182800.md lines 187-218 (Settings Don't Support Agent Selection)

### Description
Extend the settings system to support agent type selection. Add a new `agent` section to `ToolAgentSettings` with agent type and configuration. Update the settings UI (in `main.ts`) to include a dropdown for agent selection.

**Current Settings Structure** (lines 192-199):
```typescript
llm: {
  provider: "openai" | "anthropic" | "custom";
  model: string;
  // ... provider config
}
```

**Target Settings Structure** (lines 200-218):
```typescript
agent: {
  type: "wand";  // Only "wand" initially, future: "research" | "docs" | "command"
  name?: string;  // Optional display name
  // Future: per-agent config overrides
}
llm: {
  // ... existing LLM config, shared by all agents
}
```

### Acceptance Criteria (REQUIRED)
- [ ] `src/types/settings.ts` updated with new `agent` section containing `type` field (union type: `"wand"` only for now)
- [ ] `DEFAULT_SETTINGS` includes `agent: { type: "wand" }` as default
- [ ] Migration logic in `main.ts` loadSettings: if `settings.agent` is undefined, default to `{ type: "wand" }` (handles users upgrading from old version)
- [ ] Settings UI in `main.ts` includes new "Agent Type" dropdown with single option: "Wand Agent - Plan-based automation with approval gates"
- [ ] Dropdown uses Obsidian's `Setting` API: `new Setting(containerEl).setName("Agent Type").setDesc("...").addDropdown(...)`
- [ ] Existing settings (LLM provider, approval mode, etc.) continue to work without modification
- [ ] TypeScript compiles without errors (`pnpm run typecheck`)
- [ ] Manual testing: Open settings, verify agent dropdown exists and defaults to "Wand", save settings, reload plugin, verify setting persists

### Technical Notes
- **Migration Strategy**: Use object spread to preserve backward compatibility:
  ```typescript
  const settings = Object.assign({}, DEFAULT_SETTINGS, loadedSettings);
  if (!settings.agent) settings.agent = { type: "wand" };
  ```
- **UI Placement**: Add agent dropdown at the top of settings UI, before LLM settings (establishes agent selection as primary choice)
- **Future-Proofing**: Design dropdown to support multiple agents, but only populate with "wand" this sprint:
  ```typescript
  .addDropdown(dropdown => dropdown
    .addOption("wand", "Wand Agent - Plan-based automation")
    // Future: .addOption("research", "Research Agent - Data gathering")
  )
  ```
- **No Breaking Changes**: Existing vaults without `agent` setting must continue working with Wand agent as default

---

## P0-4: Implement Agent Registry and Factory Pattern

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: P0-1 (Agent interface), P0-2 (WandAgent), P0-3 (Settings)
**Spec Reference**: N/A (new architecture) • **Status Reference**: STATUS-2025-12-27-182800.md lines 258-284 (No Agent Registry/Factory)

### Description
Create an `AgentRegistry` to manage agent type registration and instantiation. Replace hard-coded service wiring in `PluginServices.ts` with factory pattern. This enables runtime agent selection based on settings and makes it trivial to add new agent types in future sprints.

**Current PluginServices** (lines 264-267):
```typescript
this.chatController = new ChatController(
  app, settings, llmProvider, executor, toolsLayer, approvalService
);
```

**Target Pattern** (lines 272-284):
```typescript
const registry = new AgentRegistry();
registry.register('wand', new WandAgentFactory());
// Future: registry.register('research', new ResearchAgentFactory());

const agent = registry.create(settings.agent.type, {
  app, settings, llmProvider, executor, toolsLayer, approvalService
});
```

### Acceptance Criteria (REQUIRED)
- [ ] `src/agents/AgentRegistry.ts` created with methods: `register(type: string, factory: AgentFactory)`, `create(type: string, deps: AgentDependencies): Agent`, `list(): AgentInfo[]`, `has(type: string): boolean`
- [ ] `AgentFactory` interface defined with method: `create(deps: AgentDependencies): Agent`
- [ ] `AgentInfo` type defined with fields: `type`, `name`, `description`, `capabilities`
- [ ] `src/agents/WandAgentFactory.ts` created implementing `AgentFactory`, returns new `WandAgent` instance
- [ ] `src/services/PluginServices.ts` updated to use registry: instantiate `AgentRegistry`, register `WandAgentFactory`, create agent via `registry.create(settings.agent.type)`
- [ ] Registry throws descriptive error if unknown agent type requested: `throw new Error(\`Unknown agent type: \${type}. Available: \${this.list().map(a => a.type).join(', ')}\`)`
- [ ] TypeScript compiles without errors (`pnpm run typecheck`)
- [ ] Unit test: `AgentRegistry.test.ts` verifies register, create, list, has, and error handling for unknown types
- [ ] Manual testing: Plugin loads successfully, agent instantiates, basic chat interaction works

### Technical Notes
- **Singleton Registry**: AgentRegistry should be a singleton or instantiated once in PluginServices, not created per-request
- **Lazy Registration**: Register all available agents at plugin startup in `PluginServices.onload()`:
  ```typescript
  this.agentRegistry = new AgentRegistry();
  this.agentRegistry.register('wand', new WandAgentFactory());
  ```
- **Validation**: Registry should validate agent type from settings on startup, fallback to "wand" if invalid:
  ```typescript
  const agentType = this.agentRegistry.has(settings.agent.type)
    ? settings.agent.type
    : 'wand';
  ```
- **Future Extension**: Adding a new agent type in future sprint requires:
  1. Implement new agent class (e.g., `ResearchAgent`)
  2. Create factory (e.g., `ResearchAgentFactory`)
  3. Register in PluginServices: `registry.register('research', new ResearchAgentFactory())`
  4. Add option to settings dropdown

  This should be <20 lines of code outside the agent implementation itself.

---

### P1 (High) - Safety and Quality

---

## P1-1: Integration Tests for Agent Lifecycle

**Status**: Not Started
**Effort**: Medium (3-4 days)
**Dependencies**: P0-2 (WandAgent), P0-4 (Registry)
**Spec Reference**: N/A (testing) • **Status Reference**: STATUS-2025-12-27-182800.md lines 312-328 (Test Coverage Assessment)

### Description
Write integration tests to verify the agent abstraction layer works correctly and maintains backward compatibility. Tests should cover the full agent lifecycle: initialization, message handling, plan generation, state transitions, and cleanup.

**Current Test Gaps** (lines 320-325):
- ❌ No tests for multi-agent scenarios (doesn't exist yet)
- ❌ No tests for agent switching
- ❌ No tests for agent interface compliance
- ✅ Some coverage for individual services (LLMProvider, Executor)

This sprint focuses on testing the new agent infrastructure, not the underlying services (those already have unit tests).

### Acceptance Criteria (REQUIRED)
- [ ] `tests/agents/Agent.compliance.test.ts` created - tests that any `Agent` implementation satisfies interface contract (use WandAgent as test subject)
- [ ] Compliance test verifies: `initialize()` returns Promise, `handleUserMessage()` returns AgentResponse, `getState()` returns valid AgentState, `getName()/getDescription()` return non-empty strings
- [ ] `tests/agents/WandAgent.integration.test.ts` created - tests full lifecycle: initialize → handleUserMessage → plan generation → state transitions → cleanup
- [ ] Integration test fixture: "Create a file called test.md with content 'Hello World'" → Verify WandAgent returns ActionPlan with vault.createFile step
- [ ] Integration test: "WandAgent state transitions: idle → thinking (during plan gen) → idle (after response)" - mock LLM to control timing
- [ ] `tests/agents/AgentRegistry.test.ts` created - tests register, create, list, error handling for unknown types
- [ ] All existing unit tests pass (`pnpm run test`) - no regressions
- [ ] New tests pass: `pnpm run test -- tests/agents/`
- [ ] Test coverage report shows agent/ directory has >80% line coverage (run `pnpm run test -- --coverage`)

### Technical Notes
- **Mocking Strategy**: Mock LLMProvider to return deterministic ActionPlans (avoid real API calls in tests)
- **Obsidian API Mocks**: Reuse existing mocks from `tests/__mocks__/obsidian.ts`
- **Async Testing**: Use Jest's async/await patterns:
  ```typescript
  test('WandAgent generates plan for user message', async () => {
    const agent = new WandAgent(mockDeps);
    await agent.initialize();
    const response = await agent.handleUserMessage('Create test.md');
    expect(response.type).toBe('plan');
    expect(response.content.steps).toHaveLength(1);
  });
  ```
- **State Verification**: Test state transitions using `onStateChange` callback:
  ```typescript
  const states: AgentState[] = [];
  agent.onStateChange(state => states.push(state));
  await agent.handleUserMessage('...');
  expect(states).toContainEqual({ status: 'thinking', ... });
  ```
- **Agent Compliance Test Pattern**: Create reusable test suite that any future agent implementation can run to verify interface compliance

---

## P1-2: Documentation Updates

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0-1, P0-2, P0-3, P0-4 (All infrastructure complete)
**Spec Reference**: N/A (documentation) • **Status Reference**: STATUS-2025-12-27-182800.md lines 574-583 (Priority 5: Documentation and Migration)

### Description
Update project documentation to reflect the new agent abstraction architecture. Users and future developers need to understand: (1) what agents are, (2) how to select an agent, (3) what the Wand agent does, and (4) how to implement a new agent in the future.

### Acceptance Criteria (REQUIRED)
- [ ] `CLAUDE.md` updated with new "Agent Architecture" section explaining: Agent interface, WandAgent implementation, registry pattern, settings selection
- [ ] `CLAUDE.md` "AI Agent Architecture" section (lines 48-127) updated to reflect ChatController now delegates to Agent implementations
- [ ] `CLAUDE.md` includes code example of Agent interface signature and factory pattern usage
- [ ] `README.md` (if exists) updated with user-facing explanation: "Wand supports multiple agent types. Currently available: Wand Agent (plan-based automation)"
- [ ] Inline code comments: `src/agents/Agent.ts` interface methods have JSDoc explaining contracts
- [ ] Inline code comments: `src/agents/WandAgent.ts` has class-level JSDoc: "Default agent implementation. Generates action plans from user messages, supports placeholder resolution, approval gates, and deterministic execution."
- [ ] Settings UI tooltip: Agent dropdown includes helpful description: "Agent type determines how Wand interprets and executes your requests. Wand Agent uses plan-based execution with approval gates."

### Technical Notes
- **Audience**: Documentation targets three audiences:
  1. **End Users**: Settings tooltips, README (what agents are, how to use)
  2. **Plugin Developers**: CLAUDE.md (architecture, how to extend)
  3. **Future Maintainers**: Inline comments (why code is structured this way)
- **Migration Guide**: Not needed yet - settings migration is automatic (P0-3 handles it)
- **Future Agent Guide**: Add stub section to CLAUDE.md: "Adding a New Agent Type" with steps:
  1. Implement Agent interface
  2. Create AgentFactory
  3. Register in PluginServices
  4. Add settings dropdown option
  5. Write compliance tests
- **Keep it Minimal**: This is infrastructure documentation, not a full agent development guide (that comes when we build the second agent)

---

## P2 (Medium) - Future-Proofing

---

## P2-1: Agent Capability Declaration System

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0-1 (Agent interface), P0-2 (WandAgent)
**Spec Reference**: N/A (new architecture) • **Status Reference**: STATUS-2025-12-27-182800.md lines 138-145 (AgentCapability enum)

### Description
Implement the capability declaration system where agents advertise their capabilities (`planning`, `execution`, `conversation`, `multi-step`, `research`). This enables future UI features like filtering agents by capability or showing capability badges in the agent selection dropdown.

This is optional polish for the agent abstraction layer - it doesn't affect core functionality but makes the system more extensible for future agent types.

### Acceptance Criteria (REQUIRED)
- [ ] `AgentCapability` enum defined in `src/agents/Agent.ts` with values: `planning`, `execution`, `conversation`, `multi-step`, `research`
- [ ] `Agent.getCapabilities()` method returns array of capabilities
- [ ] `WandAgent.getCapabilities()` returns `['planning', 'execution', 'conversation', 'multi-step']` (Wand supports all except research)
- [ ] `AgentRegistry.list()` returns agent info including capabilities for each registered agent
- [ ] Settings UI shows capabilities in agent dropdown description: "Wand Agent - Plan-based automation (Supports: planning, execution, conversation, multi-step)"
- [ ] Unit test: WandAgent reports correct capabilities, Registry list includes capabilities

### Technical Notes
- **Future Use Cases**:
  - Filter agents by capability: "Show me all agents that support planning"
  - Validate user requests: "Research tasks require an agent with 'research' capability"
  - UI badges: Show capability icons next to agent name in dropdown
- **Implementation**: Simple getter method, no complex logic:
  ```typescript
  // In WandAgent
  getCapabilities(): AgentCapability[] {
    return ['planning', 'execution', 'conversation', 'multi-step'];
  }
  ```
- **Not Used Yet**: This sprint doesn't use capabilities for routing or validation - just declares them for future use

---

## P2-2: Error Handling for Agent Switching Edge Cases

**Status**: Not Started
**Effort**: Small (1-2 days)
**Dependencies**: P0-4 (Registry)
**Spec Reference**: N/A (error handling) • **Status Reference**: STATUS-2025-12-27-182800.md lines 333-367 (Dependencies and Risks)

### Description
Add robust error handling for edge cases in agent switching: unknown agent type in settings, agent initialization failures, agent state corruption, registry misconfiguration. Ensure graceful degradation - if the configured agent fails to load, fallback to WandAgent and notify the user.

### Acceptance Criteria (REQUIRED)
- [ ] If `settings.agent.type` is unknown (not registered), log warning and fallback to "wand": `console.warn(\`Unknown agent type '\${type}', falling back to 'wand'\`)`
- [ ] If agent factory throws during creation, catch error, log, fallback to Wand, show user notice: "Failed to initialize [AgentName] agent, using Wand agent instead"
- [ ] If agent.initialize() throws, catch error, show user error message: "Agent initialization failed: [error message]"
- [ ] If agent.handleUserMessage() throws unhandled error, catch in ChatController, set agent state to 'error', display error to user (don't crash plugin)
- [ ] Settings migration: if `settings.agent` is invalid type (e.g., corrupted JSON), reset to default `{ type: "wand" }`
- [ ] Unit tests for error scenarios: unknown agent type, factory throws, initialize throws, handleUserMessage throws
- [ ] Manual testing: Manually edit settings.json to invalid agent type, reload plugin, verify fallback to Wand

### Technical Notes
- **Graceful Degradation Philosophy**: Never crash the plugin - always have a working agent (Wand) available
- **User Visibility**: Don't silently fail - show Obsidian notices for errors:
  ```typescript
  new Notice('Failed to load Research agent, using Wand agent instead');
  ```
- **Logging**: Use console.warn for recoverable issues, console.error for unexpected failures
- **Validation**: Add `validateAgentSettings()` helper in PluginServices to check settings integrity on load

---

## Dependency Graph

```
P0-1 (Agent Interface)
  └─> P0-2 (WandAgent)
        └─> P0-3 (Settings)
        └─> P0-4 (Registry)
              └─> P1-1 (Integration Tests)
              └─> P1-2 (Documentation)
                    └─> P2-1 (Capabilities)
                    └─> P2-2 (Error Handling)
```

**Critical Path**: P0-1 → P0-2 → P0-4 → P1-1 (must complete in order)
**Parallel Work**: After P0-2, can work on P0-3 and P0-4 simultaneously
**Polish Phase**: P2-1 and P2-2 can be done in parallel after P1-2

---

## Recommended Sprint Planning

### Week 1: Foundation
- **Days 1-2**: P0-1 (Agent Interface) - get agreement on interface design, implement types
- **Days 3-5**: P0-2 (WandAgent) - start extraction, high-risk refactor, continuous testing

### Week 2: Integration
- **Days 1-2**: P0-2 (WandAgent) - finish extraction, pass all existing tests
- **Days 3-4**: P0-3 (Settings) + P0-4 (Registry) - parallel work if possible
- **Day 5**: P1-1 (Integration Tests) - start test suite

### Week 3: Quality and Polish
- **Days 1-2**: P1-1 (Integration Tests) - finish tests, achieve coverage targets
- **Day 3**: P1-2 (Documentation) - update docs
- **Days 4-5**: P2-1 (Capabilities) + P2-2 (Error Handling) - optional polish

**Total**: 15 days (3 weeks) with built-in buffer

---

## Risk Assessment

### High-Risk Items

**Risk 1: WandAgent Extraction Breaks Existing Functionality** (P0-2)
- **Impact**: Users can't use plugin, plans fail to generate
- **Likelihood**: Medium - large refactor touching core logic
- **Mitigation**:
  - Incremental approach: copy then replace, not move
  - Run full test suite after each commit
  - Manual testing with real user messages
  - Keep feature flag to toggle between old/new architecture during migration

**Risk 2: Settings Migration Fails for Existing Users** (P0-3)
- **Impact**: Users lose settings, plugin doesn't load
- **Likelihood**: Low - migration is simple default assignment
- **Mitigation**:
  - Test migration with real vault settings files
  - Validate settings structure on load
  - Preserve all existing settings fields
  - Document migration in CHANGELOG

**Risk 3: Test Coverage Gaps Hide Regressions** (P1-1)
- **Impact**: Bugs ship to users, discovered after release
- **Likelihood**: Medium - refactoring can introduce subtle bugs
- **Mitigation**:
  - Write integration tests BEFORE refactoring (capture current behavior)
  - Test common user workflows manually
  - Use TypeScript strict mode to catch type errors
  - Request community beta testing before release

### Medium-Risk Items

**Risk 4: Interface Design Doesn't Support Future Agents**
- **Impact**: Need to redesign interface, break WandAgent implementation
- **Likelihood**: Low - interface design based on STATUS analysis of 5 agent types
- **Mitigation**:
  - Review interface design with STATUS ambiguity resolutions
  - Design for current needs, not speculative features (YAGNI)
  - Accept that interface may evolve - prefer small breaking changes over over-engineering

---

## Success Metrics

### Functional Metrics
- [ ] **Backward Compatibility**: 100% of existing functionality works identically
  - Test: Run plugin with new code, verify all previous user workflows succeed
- [ ] **Agent Instantiation**: WandAgent instantiates via registry, not direct constructor
  - Test: Grep codebase for `new WandAgent(` outside of factory - should only appear in WandAgentFactory
- [ ] **Settings Persistence**: Agent selection survives plugin reload
  - Test: Select Wand in settings, reload Obsidian, verify still Wand
- [ ] **Type Safety**: No TypeScript errors, no `any` types in agent layer
  - Test: `pnpm run typecheck` passes

### Quality Metrics
- [ ] **Test Coverage**: Agent layer >80% line coverage
  - Test: `pnpm run test -- --coverage`
- [ ] **Test Pass Rate**: All tests pass (unit + integration)
  - Test: `pnpm run test` exit code 0
- [ ] **Build Success**: Plugin builds without errors
  - Test: `pnpm run build` produces `main.js`
- [ ] **Runtime Stability**: No console errors during normal usage
  - Test: Manual usage for 30 minutes, check DevTools console

### Code Quality Metrics
- [ ] **ChatController Size**: Reduced from 929 lines to <300 lines
  - Test: `wc -l src/services/ChatController.ts`
- [ ] **Separation of Concerns**: Agent-specific logic isolated to WandAgent
  - Test: Code review - ChatController only delegates, no hard-coded prompts
- [ ] **Extensibility**: Adding a new agent requires <100 LOC (interface impl + factory)
  - Test: Estimate LOC for hypothetical ResearchAgent skeleton

---

## Blockers and Questions for User

### Ambiguity Resolutions Needed (from STATUS lines 369-481)

**DECISION REQUIRED**: The STATUS report identified 4 ambiguities. Proposed resolutions below - user should confirm or provide alternative:

**1. Agent Boundary** (STATUS lines 373-397)
- **Proposal**: Option B - Agents own prompts + planning logic, share executor
- **Rationale**: Executor is deterministic and agent-agnostic, no need to duplicate
- **Impact**: All agents use same Executor service, can customize retry strategies if needed
- **❓ User Decision Required?**: Accept proposal or specify different boundary?

**2. Agent Chaining** (STATUS lines 399-425)
- **Proposal**: Option A (Independent) - Each agent handles requests solo, no delegation
- **Rationale**: YAGNI - no current use case, can add later if needed
- **Future-Proofing**: Design Agent interface to allow future `delegateTo()` method
- **❓ User Decision Required?**: Accept proposal or plan for chaining from start?

**3. Agent Selection** (STATUS lines 426-448)
- **Proposal**: Manual selection initially (dropdown in settings), design for future auto-routing
- **Rationale**: Manual is simpler to implement and debug, less magic
- **Future**: Add `canHandle()` method to Agent interface for future auto-routing
- **❓ User Decision Required?**: Accept proposal or implement auto-routing this sprint?

**4. LLM Provider Per-Agent** (STATUS lines 451-481)
- **Proposal**: Shared LLM provider (global settings), design for future per-agent override
- **Rationale**: Simpler for this sprint, matches current settings model
- **Future**: Add optional `llm` field to `agent` settings for per-agent override
- **❓ User Decision Required?**: Accept proposal or implement per-agent LLM this sprint?

### Clarifications Needed

**Q1**: Should the Agent interface support undo/redo capabilities?
- STATUS mentions Executor has undo journal (stub) - should agents expose undo?
- Proposal: Not this sprint - undo is Executor concern, not agent concern

**Q2**: How should agents handle streaming responses (LLM streaming)?
- Current ChatController supports streaming (settings.llm.streaming)
- Proposal: Agent.handleUserMessage() returns AgentResponse with streaming flag, ChatController handles streaming display

**Q3**: Should agent state be persisted across plugin reloads?
- Current ChatController doesn't persist state (only chat history)
- Proposal: Agent state is ephemeral (idle on startup), chat history persisted separately

**Q4**: What happens if user switches agent type mid-conversation?
- Settings allow changing agent type - what happens to current conversation?
- Proposal: This sprint doesn't support mid-conversation switching (requires plugin reload). Future sprint can add graceful handoff.

---

## Files to Create (This Sprint)

**New Directories**:
- `src/agents/` (new directory for agent implementations)

**New Files**:
- `src/agents/Agent.ts` (P0-1) - Interface and type definitions
- `src/agents/WandAgent.ts` (P0-2) - Wand implementation
- `src/agents/AgentRegistry.ts` (P0-4) - Registry and factory types
- `src/agents/WandAgentFactory.ts` (P0-4) - Factory for WandAgent
- `tests/agents/Agent.compliance.test.ts` (P1-1) - Interface compliance tests
- `tests/agents/WandAgent.integration.test.ts` (P1-1) - Lifecycle integration tests
- `tests/agents/AgentRegistry.test.ts` (P1-1) - Registry unit tests

**Modified Files**:
- `src/types/settings.ts` (P0-3) - Add `agent` section
- `src/services/ChatController.ts` (P0-2) - Refactor to thin orchestrator
- `src/services/PluginServices.ts` (P0-4) - Use registry instead of direct instantiation
- `src/main.ts` (P0-3) - Add agent dropdown to settings UI
- `CLAUDE.md` (P1-2) - Update architecture documentation

---

## Definition of Done (Sprint Complete When...)

**Functional**:
- [ ] Plugin loads successfully with Wand agent
- [ ] User can send message "Create daily note for today" and get plan
- [ ] Plan execution works identically to pre-refactor
- [ ] Settings show agent dropdown with "Wand" option
- [ ] Settings persist and migrate correctly

**Technical**:
- [ ] Agent interface defined and documented
- [ ] WandAgent implements interface completely
- [ ] ChatController refactored to <300 lines
- [ ] AgentRegistry instantiates agents via factory pattern
- [ ] TypeScript compiles without errors
- [ ] All existing tests pass
- [ ] New integration tests pass with >80% coverage

**Quality**:
- [ ] Code review confirms separation of concerns
- [ ] Documentation updated (CLAUDE.md, inline comments)
- [ ] No console errors during manual testing
- [ ] Settings migration tested with real vault

**User Impact**:
- [ ] Zero user-facing changes (backward compatible)
- [ ] Plugin works identically to previous version
- [ ] Settings show new agent dropdown (future-proofing)

---

## Post-Sprint: Validation Checklist

Before marking sprint complete, run this validation:

```bash
# TypeScript
pnpm run typecheck  # Must pass with 0 errors

# Tests
pnpm run test       # All tests pass
pnpm run test -- --coverage  # Agent layer >80% coverage

# Build
pnpm run build      # Produces main.js without errors

# Manual Testing (use test vault)
just setup          # Install to test vault
just obsidian       # Launch with debugging
# Test scenarios:
# 1. Send message "Create test.md with content Hello"
# 2. Verify plan generates
# 3. Approve and execute
# 4. Verify file created
# 5. Check DevTools console for errors (should be none)
# 6. Reload plugin
# 7. Verify agent still Wand, settings persist
```

---

## Next Sprint Preview

**Future Sprint**: Implement Second Agent (ResearchAgent)

Once the abstraction layer is complete, the next sprint will validate it by implementing a second agent type. The ResearchAgent will:
- Focus on data gathering and analysis
- Use read-only tools only (vault.search, vault.read, dataview queries)
- Return findings, not action plans (different response type)
- Simpler than Wand (no placeholder resolution, no execution)

**Estimated Effort**: 1 week (because infrastructure already exists)

**Success Criteria**: ResearchAgent implementation requires:
- <100 LOC agent implementation
- 1 factory class
- 1 registry line
- 1 settings dropdown option
- Compliance tests pass automatically (interface contract validated)

If we can't build ResearchAgent in ~1 week with <100 LOC, it means our abstraction is insufficient.

---

## Appendix: Key Code Locations

**Current Implementation** (before refactor):
- `src/services/ChatController.ts:731-851` - System prompt (move to WandAgent)
- `src/services/ChatController.ts:523-639` - Plan generation with retry (move to WandAgent)
- `src/services/ChatController.ts:641-729` - Placeholder resolution (move to WandAgent)
- `src/services/ChatController.ts:129-197` - sendMessage() orchestration (delegate to Agent)
- `src/services/PluginServices.ts:77` - Service instantiation (replace with registry)
- `src/types/settings.ts:3-41` - Settings interface (add agent section)

**Test Fixtures**:
- `tests/__mocks__/obsidian.ts` - Obsidian API mocks (reuse for agent tests)
- `tests/services/Executor.test.ts` - Example integration test pattern
- `tests/services/PlanValidator.test.ts` - Example schema validation test

**Documentation**:
- `CLAUDE.md:48-127` - Current architecture (update with agent abstraction)
- `README.md` - User-facing docs (update with agent selection)

---

**End of Sprint Plan**
