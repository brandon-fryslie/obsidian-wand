# Status Report - Agent Abstraction Layer
Timestamp: 2025-12-27-182800
Scope: project/full
Confidence: FRESH

## Executive Summary
**Overall**: Architecture tightly coupled to single agent pattern | Critical refactoring needed | Tests insufficient
**Critical Issues**: 5 major coupling points | No agent interface | Settings limited to LLM selection only
**Tests Reliable**: Partial - unit tests exist but no integration coverage for multi-agent scenarios

## Evaluation Reuse Summary
- No previous evaluations for this scope
- Fresh evaluation: Complete architecture assessment
- Sources examined: 8 core services, type definitions, settings, DI container

---

## What Exists: Current Agent Architecture

### Core Components (src/services/)

**ChatController.ts** (929 lines)
- **Role**: Main orchestration layer - handles conversation flow, plan generation with retry, approval checking, execution
- **Responsibilities**:
  - Manages chat state (messages, current plan, execution progress)
  - Coordinates LLM ‚Üí validation ‚Üí approval ‚Üí execution pipeline
  - Implements placeholder resolution (iterative LLM calls with gathered data)
  - Handles plan revision based on user feedback
- **Status**: COMPLETE but monolithic - tightly couples the entire agent lifecycle

**LLMProvider.ts** (485 lines)
- **Role**: Abstraction over multiple LLM providers (OpenAI, Anthropic, Custom)
- **Responsibilities**:
  - Provider selection based on settings
  - Request/response handling with abort support
  - Streaming and non-streaming modes
- **Status**: COMPLETE - Already modular and swappable via settings
- **Interface**: Abstract base class `BaseLLMProvider` with concrete implementations

**PlanGenerator.ts** (748 lines)
- **Role**: Plan generation from user prompts with context
- **Responsibilities**:
  - Builds system and user prompts
  - Executes read-only steps to gather data
  - Iterative placeholder resolution (up to 3 attempts)
  - Creates `Plan` objects in PlanStore
- **Status**: COMPLETE but couples plan generation with storage

**Executor.ts** (360 lines)
- **Role**: Deterministic plan execution
- **Responsibilities**:
  - Executes steps in dependency order
  - Handles foreach loops, retries, error strategies
  - Progress callbacks with real-time updates
  - Undo journal (stub implementation)
- **Status**: COMPLETE - Well-abstracted from planning

**ToolsLayer.ts** (958 lines)
- **Role**: Tool execution abstraction
- **Responsibilities**:
  - Dispatches to 40+ tools across vault, editor, workspace, plugins
  - Integrates with Dataview, Templater, Tasks, Advanced Tables, Excalidraw
  - Path resolution and validation
- **Status**: COMPLETE - Already abstracted from agent logic

**ApprovalService.ts** (221 lines)
- **Role**: Approval decision logic
- **Responsibilities**:
  - Checks if step needs approval (mode: yolo/ask/paranoid)
  - Manages session approvals (temporary) and allowlist (permanent)
  - Path-based approval patterns
- **Status**: COMPLETE - Could be agent-specific config

**PluginServices.ts** (77 lines)
- **Role**: Dependency injection container
- **Current wiring**: Hard-coded single agent architecture
  ```typescript
  this.chatController = new ChatController(
    app, settings, llmProvider, executor, toolsLayer, approvalService
  )
  ```
- **Status**: COMPLETE but rigid - no abstraction for multiple agents

### Type Definitions

**ActionPlan.ts** (128 lines)
- Core data structure for plans
- 40+ tool names defined
- `ExecutionContext` with variables, step results, available commands
- **Status**: COMPLETE - Agent-agnostic

**settings.ts** (106 lines)
- **LLM config**: Provider selection, API keys, model, temperature, streaming
- **Approval config**: Mode, allowed/denied tools, paths, session memory
- **Chat config**: History, thinking, auto-save, persistence
- **UI config**: Theme, font size, ribbon icon
- **Gap**: No concept of "agent type" - only LLM provider selection

---

## What's Missing: Common Agent API/Interface

### No Agent Abstraction Layer

**Current Problem**: Everything assumes the single "Wand" agent pattern:
1. User message ‚Üí LLM generates plan ‚Üí Validate ‚Üí Approve ‚Üí Execute

**What's Needed**: Abstract `Agent` interface that different implementations can satisfy:

```typescript
interface Agent {
  // Core lifecycle
  initialize(): Promise<void>;
  handleUserMessage(message: string, context: ExecutionContext): Promise<AgentResponse>;
  cleanup(): void;

  // Configuration
  getName(): string;
  getDescription(): string;
  getCapabilities(): AgentCapability[];

  // State management
  getState(): AgentState;
  onStateChange(callback: (state: AgentState) => void): void;

  // Control
  abort(): void;
  canHandle(message: string, context: ExecutionContext): Promise<boolean>;
}

interface AgentResponse {
  type: 'plan' | 'message' | 'error';
  content: any;
  requiresApproval: boolean;
  // ... metadata
}

type AgentCapability =
  | 'planning'      // Generates ActionPlans
  | 'execution'     // Executes plans
  | 'conversation'  // Maintains chat history
  | 'learning'      // Learns from feedback
  | 'multi-step'    // Iterative workflows
  | 'research'      // External data gathering
```

**Missing Agent Variants**:
1. **Current "Wand" agent** - Plan-based, approval-gated
2. **Research agent** - Multi-step data gathering, no execution
3. **Code generation agent** - Creates code snippets, different prompt strategy
4. **Documentation agent** - Reads vault, generates summaries/indexes
5. **Simple command agent** - Direct execution, no planning phase

---

## What Needs Changes: Coupling Points

### 1. ChatController is Monolithic (MAJOR)

**Problem**: ChatController couples all agent responsibilities:
- Prompt building (lines 731-851)
- Plan generation with retry (lines 523-639)
- Placeholder resolution (lines 641-729)
- Approval checking (lines 226-248)
- Execution orchestration (lines 299-364)
- Message formatting (lines 853-889)

**Evidence**:
```typescript
// ChatController owns the entire workflow
async sendMessage(message: string): Promise<void> {
  // 1. Gather context (line 129)
  // 2. Generate plan with retry (line 135)
  // 3. Check approvals (line 141)
  // 4. Format response (line 169)
  // 5. Auto-execute if approved (line 192-197)
}
```

**Impact**: Cannot introduce a different agent without rewriting ChatController

**What to Change**:
- Extract planning strategy into `PlanningStrategy` interface
- Extract prompt building into `PromptBuilder` interface
- Move agent-specific logic into concrete `Agent` implementations
- ChatController becomes a thin orchestrator that delegates to `Agent`

### 2. Settings Don't Support Agent Selection (MAJOR)

**Problem**: Settings only allow LLM provider selection, not agent type

**Current settings.llm**:
```typescript
llm: {
  provider: "openai" | "anthropic" | "custom";  // Provider, not agent
  model: string;
  // ... provider config
}
```

**What's Missing**:
```typescript
agent: {
  type: "wand" | "research" | "docs" | "command";  // Agent type
  provider: "openai" | "anthropic" | "custom";     // Which LLM to use
  model: string;
  // Agent-specific config
  customPrompts?: Record<string, string>;
  capabilities?: AgentCapability[];
}
```

**Impact**: No UI/UX for selecting agent type

**What to Change**:
- Add `agent` section to `ToolAgentSettings`
- Update settings UI to include agent dropdown
- Support per-agent configuration overrides

### 3. Hard-Coded Prompt Strategy (MAJOR)

**Problem**: System prompt is hard-coded in ChatController (line 731)

**Evidence**:
```typescript
private buildSystemPrompt(): string {
  return `You are Wand, an intelligent Obsidian automation assistant...`;
  // 100+ lines of hard-coded prompt
}
```

**Impact**: Cannot change prompt strategy without modifying ChatController

**What to Change**:
- Extract to `PromptBuilder` interface with implementations:
  - `WandPromptBuilder` - Current comprehensive prompt
  - `ResearchPromptBuilder` - Data gathering focused
  - `DocsPromptBuilder` - Documentation generation focused
- Load prompts from config or external files

### 4. PlanGenerator Assumes Single Workflow (MODERATE)

**Problem**: PlanGenerator hard-codes the Wand workflow:
1. Generate plan
2. Validate
3. Execute read-only steps
4. Regenerate with data (up to 3 attempts)

**Evidence**: Lines 78-120 implement placeholder resolution loop

**Impact**: Other agents may not need this multi-pass approach

**What to Change**:
- Make PlanGenerator a strategy that Wand agent uses
- Other agents can use different planning strategies or skip planning entirely
- Extract `PlaceholderResolver` as separate component

### 5. No Agent Registry/Factory (MAJOR)

**Problem**: PluginServices.ts hard-codes service instantiation

**Evidence**:
```typescript
this.chatController = new ChatController(
  app, settings, llmProvider, executor, toolsLayer, approvalService
);
```

**Impact**: Cannot register multiple agent types or select at runtime

**What's Needed**:
```typescript
class AgentRegistry {
  register(type: string, factory: AgentFactory): void;
  create(type: string, deps: AgentDependencies): Agent;
  list(): AgentInfo[];
}

// Usage
registry.register('wand', new WandAgentFactory());
registry.register('research', new ResearchAgentFactory());

const agent = registry.create(settings.agent.type, { app, llmProvider, ... });
```

---

## Data Flow Verification

### Current Agent Lifecycle

| Phase | Input | Process | Store | Retrieve | Display |
|-------|-------|---------|-------|----------|---------|
| **User Input** | ‚úÖ Message from ChatView | ‚úÖ ChatController.sendMessage | ‚úÖ Chat state | ‚úÖ Rendered in MessageList | ‚úÖ Works |
| **Plan Generation** | ‚úÖ Context + message | ‚úÖ LLM call ‚Üí JSON | ‚úÖ Current plan in state | ‚úÖ Retrieved for execution | ‚úÖ Works |
| **Approval** | ‚úÖ Plan steps | ‚úÖ ApprovalService checks | ‚úÖ Step approvals in state | ‚úÖ UI reads approvals | ‚úÖ Works |
| **Execution** | ‚úÖ Approved plan | ‚úÖ Executor runs steps | ‚úÖ Results in ExecutionResult[] | ‚úÖ Added to message | ‚úÖ Works |

**Data Flow Assessment**: Current single-agent flow works correctly. Problem is it cannot be adapted to other agent patterns without major refactoring.

---

## Runtime Check Results

### Existing Checks
| Check Command | Purpose | Status |
|---------------|---------|--------|
| `npm run test` | Jest unit tests | PARTIAL (tests exist but limited) |
| `npm run test:e2e` | Playwright E2E tests | UNKNOWN (e2e/ dir exists) |
| `npm run build` | TypeScript compilation | ASSUMED PASSING |
| `npm run typecheck` | Type validation | AVAILABLE |

### Test Coverage Assessment

**Unit Tests Found** (tests/ directory):
- `__mocks__/` - Obsidian API mocks
- `schemas/` - Schema validation tests
- `services/` - Service layer tests (5 files)
- `utils/` - Utility tests

**Coverage Gaps**:
- ‚ùå No tests for multi-agent scenarios (doesn't exist yet)
- ‚ùå No tests for agent switching
- ‚ùå No tests for agent interface compliance
- ‚úÖ Some coverage for individual services (LLMProvider, Executor, etc.)

**Test Quality**: Tests appear to be unit tests for existing components. No integration tests for agent lifecycle.

---

## Dependencies and Risks

### Breaking Changes Assessment

**IF we refactor to support multiple agents:**

| Component | Breaking Change? | Migration Path | Risk |
|-----------|------------------|----------------|------|
| **ChatController** | ‚úÖ YES - becomes thin orchestrator | Extract logic to WandAgent | HIGH - touches everything |
| **Settings** | ‚úÖ YES - adds agent.type field | Migration: default to "wand" | MEDIUM - user configs |
| **PluginServices** | ‚úÖ YES - factory pattern | Replace direct instantiation | MEDIUM - DI changes |
| **PlanGenerator** | ‚ö†Ô∏è MAYBE - used by WandAgent only | Becomes WandAgent internal | LOW - optional |
| **LLMProvider** | ‚ùå NO - already abstracted | No change needed | NONE |
| **Executor** | ‚ùå NO - used by all agents | No change needed | NONE |
| **ToolsLayer** | ‚ùå NO - shared by all agents | No change needed | NONE |
| **ApprovalService** | ‚ö†Ô∏è MAYBE - per-agent config | Agent-specific settings | LOW - config change |

### Risk Mitigation

**High Risk: ChatController Refactor**
- **Mitigation**:
  1. Create `Agent` interface first
  2. Implement `WandAgent` using existing ChatController code
  3. Replace ChatController incrementally
  4. Keep backward compatibility with feature flag

**Medium Risk: Settings Migration**
- **Mitigation**:
  1. Default missing `agent.type` to "wand"
  2. Migrate old `llm` config to `agent` config
  3. Document migration in CHANGELOG

**Test Coverage Gap**
- **Mitigation**:
  1. Write integration tests for current Wand agent first
  2. Create agent interface compliance tests
  3. Test each new agent implementation

---

## Ambiguities Found

### 1. What Constitutes the "Agent" Boundary?

**Question**: Which components are agent-specific vs. shared infrastructure?

**Options**:
- **Option A**: Agent = (Prompts + Planning + Execution)
  - Each agent has own prompt builder, planning strategy, execution flow
  - Shared: LLMProvider, ToolsLayer, ApprovalService

- **Option B**: Agent = (Prompts + Planning only)
  - Each agent generates plans differently
  - Shared: Executor, ToolsLayer, ApprovalService, LLMProvider

- **Option C**: Agent = (Prompts only)
  - Only system prompts differ
  - Shared: Everything else

**Current Implementation Suggests**: Option A (comprehensive agent ownership)
- ChatController owns prompts, planning, AND execution orchestration
- But Executor is already abstracted and could be shared

**Recommendation**: **Option B** - Agents own prompts + planning logic, share executor
- **Rationale**: Executor is deterministic and agent-agnostic
- **Tradeoff**: Some agents may need custom execution (research agent might need different retry strategies)
- **Resolution Needed**: Confirm agent ownership boundaries with user

### 2. Should Agents Chain or Operate Independently?

**Question**: Can one agent delegate to another? (e.g., Wand agent calls Research agent)

**Options**:
- **Option A**: Independent - Each agent handles requests solo
  - Simpler implementation
  - User must manually switch agents

- **Option B**: Chaining - Agents can delegate to specialists
  - More powerful
  - Requires agent communication protocol

- **Option C**: Hybrid - Main agent can spawn sub-agents for specific tasks
  - Flexible
  - Complex lifecycle management

**Current Implementation**: N/A - only one agent exists

**Impact of Wrong Choice**:
- If we choose A and need B later: Major refactor to add agent communication
- If we choose B but only need A: Over-engineering, unnecessary complexity

**Recommendation**: **Start with Option A**, design for future B
- **Rationale**: YAGNI - no current use case for chaining
- **Design Consideration**: Make Agent interface support future `delegateTo()` method

### 3. Agent Selection: Automatic vs. Manual?

**Question**: Does user manually select agent, or does system auto-select based on message?

**Options**:
- **Manual**: Dropdown in UI, user picks agent type
  - Simple, predictable
  - User must know which agent to use

- **Automatic**: Analyze message, route to appropriate agent
  - Better UX
  - Requires routing logic and agent scoring

- **Hybrid**: Default agent, with manual override

**Current Implementation**: N/A - only one agent

**User Impact**:
- Manual: "Select Research Agent from dropdown, then ask question"
- Automatic: "Just ask question, system routes to best agent"

**Recommendation**: **Start Manual, plan for Automatic**
- **Rationale**: Manual is easier to implement and debug
- **Future**: Add `canHandle()` method to Agent interface for auto-routing

### 4. LLM Provider Per-Agent or Shared?

**Question**: Can different agents use different LLM providers?

**Options**:
- **Shared**: One LLM provider for all agents (current settings model)
  - Simpler
  - Cheaper (one API key)

- **Per-Agent**: Each agent can use different provider/model
  - More flexible
  - Example: Wand uses GPT-4, Research uses Claude Opus

**Current Implementation**: Shared (settings.llm applies to all)

**Impact**:
- If shared but need per-agent: Users can't optimize cost/performance per task
- If per-agent but only need shared: Extra config complexity

**Recommendation**: **Support both** - Agent inherits from global, can override
```typescript
agent: {
  type: "wand";
  // Optional: override global LLM settings
  llm?: {
    provider: "anthropic";
    model: "claude-3-opus";
  }
}
```

---

## Implementation Assessment

### Current Implementation Status

**Strengths**:
- ‚úÖ LLMProvider already modular (supports OpenAI, Anthropic, Custom)
- ‚úÖ Executor is deterministic and agent-agnostic
- ‚úÖ ToolsLayer well-abstracted from agent logic
- ‚úÖ Strong type safety with TypeScript and Zod schemas

**Weaknesses**:
- ‚ùå ChatController is monolithic - couples all agent concerns
- ‚ùå No Agent abstraction or interface
- ‚ùå Settings don't support agent selection
- ‚ùå Hard-coded prompts and planning strategy
- ‚ùå No factory/registry for agent types

**Red Flags**:
- üö© ChatController at 929 lines - too many responsibilities
- üö© System prompt hard-coded (100+ lines in method)
- üö© Placeholder resolution logic buried in ChatController
- üö© No separation between agent behavior and orchestration

**Test Coverage Gaps**:
- üö© No integration tests for agent lifecycle
- üö© No tests for error paths (what if LLM returns invalid JSON?)
- üö© No tests for concurrent operations (cancellation during execution)

---

## Recommendations

### Priority 1: Define Agent Interface (CRITICAL)

**Why**: Foundation for everything else - cannot proceed without it

**Tasks**:
1. Create `src/agents/Agent.ts` interface
2. Define `AgentResponse`, `AgentState`, `AgentCapability` types
3. Document agent lifecycle and contracts
4. Write compliance tests (any Agent impl must pass)

**Estimated Effort**: 2-3 days

### Priority 2: Extract WandAgent (HIGH)

**Why**: Preserve existing functionality while enabling new agents

**Tasks**:
1. Create `src/agents/WandAgent.ts`
2. Move ChatController logic into WandAgent
3. ChatController becomes thin orchestrator
4. WandAgent owns: prompts, planning, placeholder resolution
5. Write integration tests for WandAgent

**Estimated Effort**: 1 week

**Risk**: High - touches core functionality, needs careful testing

### Priority 3: Agent Registry and Settings (HIGH)

**Why**: Enable agent selection before building new agents

**Tasks**:
1. Create `src/agents/AgentRegistry.ts`
2. Add `agent` section to settings
3. Update settings UI with agent dropdown
4. Implement agent factory pattern
5. Update PluginServices to use registry

**Estimated Effort**: 4-5 days

### Priority 4: Implement Second Agent (MEDIUM)

**Why**: Validate abstraction works with different agent type

**Suggested**: Research Agent
- Focused on data gathering
- No execution phase
- Simpler than Wand (validates minimal agent works)

**Tasks**:
1. Create `ResearchAgent.ts` implementing `Agent`
2. Custom prompts focused on search/analysis
3. Uses read-only tools only
4. Returns findings, not action plans

**Estimated Effort**: 1 week

### Priority 5: Documentation and Migration (MEDIUM)

**Why**: Users need guidance on agent selection and migration

**Tasks**:
1. Document each agent type's purpose and capabilities
2. Update settings migration logic
3. Create "Which agent should I use?" guide
4. Update README with agent examples

**Estimated Effort**: 2-3 days

---

## Workflow Recommendation

**CONTINUE** - Issues are clear, implementer can proceed with incremental refactor

**Recommended Approach**:
1. Start with Agent interface definition (low risk, high value)
2. Extract WandAgent without breaking existing functionality
3. Add agent registry and settings UI
4. Implement simple second agent to validate abstraction
5. Document and polish

**DO NOT attempt to refactor everything at once** - high risk of breaking working code

**DO use feature flags** - allow toggling between old and new architecture during migration

**DO write tests first** - integration tests for current behavior before refactoring

---

## Known Gaps Requiring Research/Decisions

1. **Agent boundary** - What's agent-specific vs. shared? (See Ambiguity #1)
2. **Agent chaining** - Support delegation between agents? (See Ambiguity #2)
3. **Agent selection** - Manual or automatic routing? (See Ambiguity #3)
4. **LLM per-agent** - Shared or per-agent LLM config? (See Ambiguity #4)

**Recommendation**: User should review ambiguities and provide guidance before implementation begins.

---

## Files Examined

**Services** (src/services/):
- ChatController.ts (929 lines) - Main orchestration, tightly coupled
- LLMProvider.ts (485 lines) - Already modular
- PlanGenerator.ts (748 lines) - Wand-specific planning
- Executor.ts (360 lines) - Agent-agnostic execution
- ToolsLayer.ts (958 lines) - Agent-agnostic tools
- ApprovalService.ts (221 lines) - Could be per-agent
- PluginServices.ts (77 lines) - DI container, needs factory pattern

**Types** (src/types/):
- ActionPlan.ts (128 lines) - Agent-agnostic data model
- settings.ts (106 lines) - Needs agent selection support

**Tests** (tests/):
- Limited unit tests exist
- No integration tests for agent lifecycle
- No multi-agent tests

---

## Next Steps for Implementer

1. **Review ambiguities** - Get user input on the 4 ambiguities identified
2. **Define Agent interface** - Start with interface definition (low risk)
3. **Write integration tests** - Test current Wand behavior before refactoring
4. **Extract WandAgent** - Incremental migration from ChatController
5. **Add agent settings** - UI and config for agent selection
6. **Implement registry** - Factory pattern for agent creation
7. **Build second agent** - Validate abstraction with different agent type

**Estimated Total Effort**: 3-4 weeks for full agent abstraction layer

**Risk Level**: HIGH - Touches core architecture, requires careful testing and incremental approach
