# Definition of Done: Agent Abstraction Layer - Infrastructure Foundation

**Generated**: 2025-12-27-183215
**Plan**: PLAN-2025-12-27-183215.md
**Sprint Goal**: Create the foundational infrastructure for multiple agent implementations without breaking existing functionality

---

## Sprint Scope

This sprint delivers **3 critical deliverables**:
1. **Agent Interface and Type System** - Foundation for all agent implementations
2. **WandAgent Implementation** - Extract existing functionality into agent pattern
3. **Agent Selection Infrastructure** - Settings, registry, factory pattern

**Deferred to future sprints**: Additional agent implementations (research, docs, command), agent chaining, per-agent LLM config, auto-routing

---

## P0-1: Define Agent Interface and Type System

**Deliverable**: Abstract Agent interface that all implementations must satisfy

### Acceptance Criteria
- [ ] `src/agents/Agent.ts` exports `Agent` interface with methods: `initialize()`, `handleUserMessage()`, `cleanup()`, `getName()`, `getDescription()`, `getCapabilities()`, `getState()`, `onStateChange()`, `abort()`
- [ ] `AgentResponse` type defined with fields: `type` (plan|message|error), `content`, `requiresApproval`, `metadata`
- [ ] `AgentState` type defined with fields: `status` (idle|thinking|executing|error), `currentPlan`, `isProcessing`, `lastError`
- [ ] `AgentCapability` enum defined with values: `planning`, `execution`, `conversation`, `multi-step`, `research`
- [ ] `AgentDependencies` interface defined with common services: `app`, `settings`, `llmProvider`, `executor`, `toolsLayer`, `approvalService`
- [ ] Interface documented with JSDoc comments explaining each method's contract and lifecycle expectations
- [ ] TypeScript compiles without errors (`pnpm run typecheck`)

---

## P0-2: Extract WandAgent from ChatController

**Deliverable**: WandAgent implementation containing all Wand-specific logic, ChatController becomes thin orchestrator

### Acceptance Criteria
- [ ] `src/agents/WandAgent.ts` created implementing `Agent` interface with all Wand-specific logic extracted from ChatController
- [ ] WandAgent owns: `buildSystemPrompt()`, `buildUserPrompt()`, `generatePlan()`, `resolvePlaceholders()`, `formatResponse()`
- [ ] ChatController refactored to <300 lines - acts as thin orchestrator delegating to `this.currentAgent`
- [ ] ChatController.sendMessage() now calls `this.currentAgent.handleUserMessage()` instead of internal logic
- [ ] Existing message flow works identically: User Input → Agent → Plan → Approval → Execution
- [ ] All existing unit tests pass without modification (if tests fail, it indicates broken backward compatibility)
- [ ] Integration test written: "WandAgent produces identical plans to legacy ChatController for same inputs" (create test fixtures from real usage)
- [ ] TypeScript compiles without errors (`pnpm run typecheck`)
- [ ] Manual testing: Open plugin, send message "Create a daily note for today", verify plan generation and execution works as before

---

## P0-3: Add Agent Selection to Settings

**Deliverable**: Settings system extended to support agent type selection with UI dropdown

### Acceptance Criteria
- [ ] `src/types/settings.ts` updated with new `agent` section containing `type` field (union type: `"wand"` only for now)
- [ ] `DEFAULT_SETTINGS` includes `agent: { type: "wand" }` as default
- [ ] Migration logic in `main.ts` loadSettings: if `settings.agent` is undefined, default to `{ type: "wand" }` (handles users upgrading from old version)
- [ ] Settings UI in `main.ts` includes new "Agent Type" dropdown with single option: "Wand Agent - Plan-based automation with approval gates"
- [ ] Dropdown uses Obsidian's `Setting` API: `new Setting(containerEl).setName("Agent Type").setDesc("...").addDropdown(...)`
- [ ] Existing settings (LLM provider, approval mode, etc.) continue to work without modification
- [ ] TypeScript compiles without errors (`pnpm run typecheck`)
- [ ] Manual testing: Open settings, verify agent dropdown exists and defaults to "Wand", save settings, reload plugin, verify setting persists

---

## P0-4: Implement Agent Registry and Factory Pattern

**Deliverable**: AgentRegistry manages agent type registration and runtime instantiation

### Acceptance Criteria
- [ ] `src/agents/AgentRegistry.ts` created with methods: `register(type: string, factory: AgentFactory)`, `create(type: string, deps: AgentDependencies): Agent`, `list(): AgentInfo[]`, `has(type: string): boolean`
- [ ] `AgentFactory` interface defined with method: `create(deps: AgentDependencies): Agent`
- [ ] `AgentInfo` type defined with fields: `type`, `name`, `description`, `capabilities`
- [ ] `src/agents/WandAgentFactory.ts` created implementing `AgentFactory`, returns new `WandAgent` instance
- [ ] `src/services/PluginServices.ts` updated to use registry: instantiate `AgentRegistry`, register `WandAgentFactory`, create agent via `registry.create(settings.agent.type)`
- [ ] Registry throws descriptive error if unknown agent type requested: `throw new Error(\`Unknown agent type: \${type}. Available: \${this.list().map(a => a.type).join(', ')}\`)`
- [ ] TypeScript compiles without errors (`pnpm run typecheck`)
- [ ] Unit test: `AgentRegistry.test.ts` verifies register, create, list, has, and error handling for unknown types
- [ ] Manual testing: Plugin loads successfully, agent instantiates, basic chat interaction works

---

## P1-1: Integration Tests for Agent Lifecycle

**Deliverable**: Comprehensive integration tests for agent infrastructure and backward compatibility

### Acceptance Criteria
- [ ] `tests/agents/Agent.compliance.test.ts` created - tests that any `Agent` implementation satisfies interface contract (use WandAgent as test subject)
- [ ] Compliance test verifies: `initialize()` returns Promise, `handleUserMessage()` returns AgentResponse, `getState()` returns valid AgentState, `getName()/getDescription()` return non-empty strings
- [ ] `tests/agents/WandAgent.integration.test.ts` created - tests full lifecycle: initialize → handleUserMessage → plan generation → state transitions → cleanup
- [ ] Integration test fixture: "Create a file called test.md with content 'Hello World'" → Verify WandAgent returns ActionPlan with vault.createFile step
- [ ] Integration test: "WandAgent state transitions: idle → thinking (during plan gen) → idle (after response)" - mock LLM to control timing
- [ ] `tests/agents/AgentRegistry.test.ts` created - tests register, create, list, error handling for unknown types
- [ ] All existing unit tests pass (`pnpm run test`) - no regressions
- [ ] New tests pass: `pnpm run test -- tests/agents/`
- [ ] Test coverage report shows agent/ directory has >80% line coverage (run `pnpm run test -- --coverage`)

---

## P1-2: Documentation Updates

**Deliverable**: Updated documentation reflecting agent abstraction architecture

### Acceptance Criteria
- [ ] `CLAUDE.md` updated with new "Agent Architecture" section explaining: Agent interface, WandAgent implementation, registry pattern, settings selection
- [ ] `CLAUDE.md` "AI Agent Architecture" section (lines 48-127) updated to reflect ChatController now delegates to Agent implementations
- [ ] `CLAUDE.md` includes code example of Agent interface signature and factory pattern usage
- [ ] `README.md` (if exists) updated with user-facing explanation: "Wand supports multiple agent types. Currently available: Wand Agent (plan-based automation)"
- [ ] Inline code comments: `src/agents/Agent.ts` interface methods have JSDoc explaining contracts
- [ ] Inline code comments: `src/agents/WandAgent.ts` has class-level JSDoc: "Default agent implementation. Generates action plans from user messages, supports placeholder resolution, approval gates, and deterministic execution."
- [ ] Settings UI tooltip: Agent dropdown includes helpful description: "Agent type determines how Wand interprets and executes your requests. Wand Agent uses plan-based execution with approval gates."

---

## P2-1: Agent Capability Declaration System

**Deliverable**: Agents can declare their capabilities for future filtering and routing

### Acceptance Criteria
- [ ] `AgentCapability` enum defined in `src/agents/Agent.ts` with values: `planning`, `execution`, `conversation`, `multi-step`, `research`
- [ ] `Agent.getCapabilities()` method returns array of capabilities
- [ ] `WandAgent.getCapabilities()` returns `['planning', 'execution', 'conversation', 'multi-step']` (Wand supports all except research)
- [ ] `AgentRegistry.list()` returns agent info including capabilities for each registered agent
- [ ] Settings UI shows capabilities in agent dropdown description: "Wand Agent - Plan-based automation (Supports: planning, execution, conversation, multi-step)"
- [ ] Unit test: WandAgent reports correct capabilities, Registry list includes capabilities

---

## P2-2: Error Handling for Agent Switching Edge Cases

**Deliverable**: Robust error handling and graceful degradation for agent initialization failures

### Acceptance Criteria
- [ ] If `settings.agent.type` is unknown (not registered), log warning and fallback to "wand": `console.warn(\`Unknown agent type '\${type}', falling back to 'wand'\`)`
- [ ] If agent factory throws during creation, catch error, log, fallback to Wand, show user notice: "Failed to initialize [AgentName] agent, using Wand agent instead"
- [ ] If agent.initialize() throws, catch error, show user error message: "Agent initialization failed: [error message]"
- [ ] If agent.handleUserMessage() throws unhandled error, catch in ChatController, set agent state to 'error', display error to user (don't crash plugin)
- [ ] Settings migration: if `settings.agent` is invalid type (e.g., corrupted JSON), reset to default `{ type: "wand" }`
- [ ] Unit tests for error scenarios: unknown agent type, factory throws, initialize throws, handleUserMessage throws
- [ ] Manual testing: Manually edit settings.json to invalid agent type, reload plugin, verify fallback to Wand

---

## Sprint-Level Success Criteria

### Functional Requirements (Must Have)
- [ ] **Backward Compatibility**: 100% of existing functionality works identically
  - Test: Run plugin with new code, verify all previous user workflows succeed
- [ ] **Agent Instantiation**: WandAgent instantiates via registry, not direct constructor
  - Test: Grep codebase for `new WandAgent(` outside of factory - should only appear in WandAgentFactory
- [ ] **Settings Persistence**: Agent selection survives plugin reload
  - Test: Select Wand in settings, reload Obsidian, verify still Wand
- [ ] **Type Safety**: No TypeScript errors, no `any` types in agent layer
  - Test: `pnpm run typecheck` passes

### Quality Requirements (Must Have)
- [ ] **Test Coverage**: Agent layer >80% line coverage
  - Test: `pnpm run test -- --coverage`
- [ ] **Test Pass Rate**: All tests pass (unit + integration)
  - Test: `pnpm run test` exit code 0
- [ ] **Build Success**: Plugin builds without errors
  - Test: `pnpm run build` produces `main.js`
- [ ] **Runtime Stability**: No console errors during normal usage
  - Test: Manual usage for 30 minutes, check DevTools console

### Code Quality Requirements (Must Have)
- [ ] **ChatController Size**: Reduced from 929 lines to <300 lines
  - Test: `wc -l src/services/ChatController.ts`
- [ ] **Separation of Concerns**: Agent-specific logic isolated to WandAgent
  - Test: Code review - ChatController only delegates, no hard-coded prompts
- [ ] **Extensibility**: Adding a new agent requires <100 LOC (interface impl + factory)
  - Test: Estimate LOC for hypothetical ResearchAgent skeleton

---

## Validation Checklist (Pre-Completion)

Run these checks before marking sprint complete:

```bash
# TypeScript compilation
pnpm run typecheck  # Must pass with 0 errors

# Test suite
pnpm run test       # All tests pass
pnpm run test -- --coverage  # Agent layer >80% coverage

# Build
pnpm run build      # Produces main.js without errors

# Manual testing (use test vault)
just setup          # Install to test vault
just obsidian       # Launch with debugging
# Test scenarios:
# 1. Send message "Create test.md with content Hello"
# 2. Verify plan generates
# 3. Approve and execute
# 4. Verify file created
# 5. Check DevTools console for errors (should be none)
# 6. Reload plugin
# 7. Verify agent still Wand, settings persist
```

---

## Definition of Sprint Complete

**The sprint is complete when**:

1. **All P0 acceptance criteria are met** (P0-1 through P0-4) - These are mandatory
2. **All P1 acceptance criteria are met** (P1-1 through P1-2) - These are mandatory
3. **P2 criteria are met OR explicitly deferred** (P2-1 through P2-2) - These are optional polish
4. **Sprint-level success criteria pass** (Functional, Quality, Code Quality)
5. **Validation checklist passes** (TypeScript, tests, build, manual testing)
6. **Zero regressions**: Existing functionality works identically to pre-refactor

**Sprint is NOT complete if**:
- Any P0 or P1 criteria unmet
- Tests failing
- TypeScript errors
- ChatController still >300 lines (indicates incomplete extraction)
- Existing user workflows broken (backward compatibility failure)

---

## Post-Sprint: Next Steps

Once this sprint is complete, the next sprint will validate the abstraction by implementing a **second agent type** (ResearchAgent).

**Success indicator**: If we can build ResearchAgent in ~1 week with <100 LOC, our abstraction is sufficient. If it takes longer or requires more code, we need to revisit the abstraction design.

**ResearchAgent scope** (future sprint):
- Read-only tools only
- Data gathering focus
- No execution phase
- Different response type (findings, not plans)
- Simpler than Wand (validates minimal agent works)

---

**End of Definition of Done**
