#!/usr/bin/env npx tsx
/**
 * Obsidian Plugin Scaffold Generator
 *
 * Creates AI-ready Obsidian plugin templates with:
 * - Full TypeScript setup
 * - Chrome DevTools Protocol debugging
 * - MCP server configuration
 * - CLAUDE.md with plugin-specific instructions
 * - Hot reload support
 * - Task runner (justfile)
 *
 * Usage:
 *   npx tsx bin/create-obsidian-plugin.ts "my-plugin" "A plugin that does X"
 *   npx tsx bin/create-obsidian-plugin.ts --wizard
 */

import * as fs from "fs";
import * as path from "path";
import * as readline from "readline";

// ============================================================================
// TYPES
// ============================================================================

interface PluginConfig {
  id: string;
  name: string;
  description: string;
  author: string;
  features: string[];
  hasSettings: boolean;
  hasCommands: boolean;
  hasSidebar: boolean;
  hasRibbon: boolean;
  outputDir: string;
}

// ============================================================================
// TEMPLATES
// ============================================================================

function generateManifest(config: PluginConfig): string {
  return JSON.stringify(
    {
      id: config.id,
      name: config.name,
      version: "0.1.0",
      minAppVersion: "0.15.0",
      description: config.description,
      author: config.author,
      authorUrl: "",
      fundingUrl: "",
      isDesktopOnly: false,
    },
    null,
    2
  );
}

function generatePackageJson(config: PluginConfig): string {
  return JSON.stringify(
    {
      name: config.id,
      version: "0.1.0",
      description: config.description,
      main: "main.js",
      scripts: {
        dev: "node esbuild.config.mjs",
        build:
          "tsc -noEmit -skipLibCheck && node esbuild.config.mjs production",
        version:
          "node version-bump.mjs && git add manifest.json versions.json",
        lint: "eslint src --ext .ts,.tsx",
        "lint:fix": "eslint src --ext .ts,.tsx --fix",
        typecheck: "tsc --noEmit",
      },
      keywords: ["obsidian", "plugin"],
      author: config.author,
      license: "MIT",
      devDependencies: {
        "@types/node": "^20.9.0",
        "@typescript-eslint/eslint-plugin": "^6.12.0",
        "@typescript-eslint/parser": "^6.12.0",
        "builtin-modules": "^3.3.0",
        esbuild: "^0.19.7",
        eslint: "^8.54.0",
        "eslint-config-prettier": "^9.0.0",
        obsidian: "^1.4.11",
        prettier: "^3.1.0",
        tslib: "^2.6.2",
        typescript: "^5.2.2",
      },
      dependencies: {},
    },
    null,
    2
  );
}

function generateTsConfig(): string {
  return JSON.stringify(
    {
      compilerOptions: {
        baseUrl: ".",
        inlineSourceMap: true,
        inlineSources: true,
        module: "ESNext",
        target: "ES6",
        allowJs: true,
        noImplicitAny: false,
        moduleResolution: "node",
        importHelpers: true,
        declaration: true,
        outDir: "lib",
        typeRoots: ["node_modules/@types"],
        lib: ["DOM", "ES6"],
        strict: true,
        noUnusedLocals: true,
        noUnusedParameters: true,
        noImplicitReturns: true,
        noFallthroughCasesInSwitch: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        resolveJsonModule: true,
      },
      include: ["**/*.ts"],
      exclude: ["node_modules", "lib", "**/*.test.ts", "**/*.spec.ts"],
    },
    null,
    2
  );
}

function generateEsbuildConfig(config: PluginConfig): string {
  return `import esbuild from "esbuild";
import process from "process";
import builtins from "builtin-modules";

const banner = \`/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
Plugin: ${config.name}
*/

\`;

const prod = process.argv[2] === "production";

const context = await esbuild.context({
  banner: {
    js: banner,
  },
  entryPoints: ["src/main.ts"],
  bundle: true,
  external: [
    "obsidian",
    "electron",
    "@codemirror/autocomplete",
    "@codemirror/collab",
    "@codemirror/commands",
    "@codemirror/language",
    "@codemirror/lint",
    "@codemirror/search",
    "@codemirror/state",
    "@codemirror/view",
    "@lezer/common",
    "@lezer/highlight",
    "@lezer/lr",
    ...builtins,
  ],
  format: "cjs",
  target: "es2018",
  logLevel: "info",
  sourcemap: prod ? false : "inline",
  treeShaking: true,
  outfile: "main.js",
});

if (prod) {
  await context.rebuild();
  process.exit(0);
} else {
  await context.watch();
}
`;
}

function generateMainTs(config: PluginConfig): string {
  const imports = [`import { Plugin } from "obsidian";`];
  const members: string[] = [];
  const onloadCode: string[] = [];
  const onunloadCode: string[] = [];

  if (config.hasSettings) {
    imports.push(
      `import { ${toPascalCase(config.id)}Settings, DEFAULT_SETTINGS, ${toPascalCase(config.id)}SettingTab } from "./settings";`
    );
    members.push(`settings!: ${toPascalCase(config.id)}Settings;`);
    onloadCode.push(`    await this.loadSettings();`);
    onloadCode.push(
      `    this.addSettingTab(new ${toPascalCase(config.id)}SettingTab(this.app, this));`
    );
  }

  if (config.hasRibbon) {
    onloadCode.push(`
    // Ribbon icon
    this.addRibbonIcon("dice", "${config.name}", () => {
      // Handle click
      console.log("${config.name} ribbon clicked");
    });`);
  }

  if (config.hasCommands) {
    onloadCode.push(`
    // Commands
    this.addCommand({
      id: "open-${config.id}",
      name: "Open ${config.name}",
      callback: () => {
        console.log("${config.name} command executed");
      },
    });`);
  }

  if (config.hasSidebar) {
    imports.push(
      `import { ${toPascalCase(config.id)}View, VIEW_TYPE_${config.id.toUpperCase().replace(/-/g, "_")} } from "./view";`
    );
    onloadCode.push(`
    // Register view
    this.registerView(
      VIEW_TYPE_${config.id.toUpperCase().replace(/-/g, "_")},
      (leaf) => new ${toPascalCase(config.id)}View(leaf)
    );

    // Activate view command
    this.addCommand({
      id: "activate-view",
      name: "Open ${config.name} sidebar",
      callback: () => this.activateView(),
    });`);

    members.push(`
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_${config.id.toUpperCase().replace(/-/g, "_")})[0];
    if (!leaf) {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        await rightLeaf.setViewState({
          type: VIEW_TYPE_${config.id.toUpperCase().replace(/-/g, "_")},
          active: true,
        });
        leaf = rightLeaf;
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }`);
  }

  const settingsCode = config.hasSettings
    ? `

  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }

  async saveSettings() {
    await this.saveData(this.settings);
  }`
    : "";

  return `${imports.join("\n")}

export default class ${toPascalCase(config.id)}Plugin extends Plugin {
  ${members.join("\n  ")}

  async onload() {
    console.log("Loading ${config.name}");
${onloadCode.join("\n")}
  }

  onunload() {
    console.log("Unloading ${config.name}");
${onunloadCode.join("\n")}
  }${settingsCode}${members.filter((m) => m.includes("async")).join("\n")}
}
`;
}

function generateSettingsTs(config: PluginConfig): string {
  if (!config.hasSettings) return "";

  const className = toPascalCase(config.id);

  return `import { App, PluginSettingTab, Setting } from "obsidian";
import type ${className}Plugin from "./main";

export interface ${className}Settings {
  // Add your settings here
  exampleSetting: string;
}

export const DEFAULT_SETTINGS: ${className}Settings = {
  exampleSetting: "default",
};

export class ${className}SettingTab extends PluginSettingTab {
  plugin: ${className}Plugin;

  constructor(app: App, plugin: ${className}Plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }

  display(): void {
    const { containerEl } = this;
    containerEl.empty();

    containerEl.createEl("h2", { text: "${config.name} Settings" });

    new Setting(containerEl)
      .setName("Example Setting")
      .setDesc("This is an example setting")
      .addText((text) =>
        text
          .setPlaceholder("Enter a value")
          .setValue(this.plugin.settings.exampleSetting)
          .onChange(async (value) => {
            this.plugin.settings.exampleSetting = value;
            await this.plugin.saveSettings();
          })
      );
  }
}
`;
}

function generateViewTs(config: PluginConfig): string {
  if (!config.hasSidebar) return "";

  const className = toPascalCase(config.id);
  const viewType = config.id.toUpperCase().replace(/-/g, "_");

  return `import { ItemView, WorkspaceLeaf } from "obsidian";

export const VIEW_TYPE_${viewType} = "${config.id}-view";

export class ${className}View extends ItemView {
  constructor(leaf: WorkspaceLeaf) {
    super(leaf);
  }

  getViewType() {
    return VIEW_TYPE_${viewType};
  }

  getDisplayText() {
    return "${config.name}";
  }

  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.createEl("h4", { text: "${config.name}" });
    container.createEl("p", { text: "Your sidebar content goes here." });
  }

  async onClose() {
    // Cleanup
  }
}
`;
}

function generateJustfile(config: PluginConfig): string {
  return `# ${config.name} - Task Runner
# Use \`just <task>\` to run tasks

# Configuration
test_vault := env_var_or_default("OBSIDIAN_TEST_VAULT", "~/obsidian-test-vault")
plugin_name := "${config.id}"
debug_port := "9222"

# List all available tasks
default:
    @just --list

# Install dependencies
install:
    pnpm install

# Development mode with hot reload
dev:
    pnpm run dev

# Production build
build:
    pnpm run build

# Run linter
lint:
    pnpm run lint

# Type checking
typecheck:
    pnpm run typecheck

# Run all validation
validate:
    @echo "Running validation suite..."
    pnpm run lint
    pnpm run typecheck
    @echo "âœ“ All validation passed!"

# Build and install plugin to test vault
setup: build
    #!/usr/bin/env bash
    set -euo pipefail
    VAULT_ARG="{{test_vault}}"
    VAULT="\${VAULT_ARG/#\\~/$HOME}"
    echo "Setting up plugin in $VAULT..."

    # Create vault if it doesn't exist
    mkdir -p "$VAULT"

    # Install our plugin (symlinked for hot reload)
    mkdir -p "$VAULT/.obsidian/plugins/{{plugin_name}}"
    ln -sf "$(pwd)/main.js" "$VAULT/.obsidian/plugins/{{plugin_name}}/main.js"
    ln -sf "$(pwd)/manifest.json" "$VAULT/.obsidian/plugins/{{plugin_name}}/manifest.json"
    ln -sf "$(pwd)/styles.css" "$VAULT/.obsidian/plugins/{{plugin_name}}/styles.css" 2>/dev/null || true
    touch "$VAULT/.obsidian/plugins/{{plugin_name}}/.hotreload"
    echo "âœ“ Plugin installed"

    # Install hot-reload plugin for development
    mkdir -p "$VAULT/.obsidian/plugins/hot-reload"
    curl -sL https://github.com/pjeby/hot-reload/releases/download/0.1.13/main.js -o "$VAULT/.obsidian/plugins/hot-reload/main.js"
    curl -sL https://github.com/pjeby/hot-reload/releases/download/0.1.13/manifest.json -o "$VAULT/.obsidian/plugins/hot-reload/manifest.json"
    echo "âœ“ Hot Reload plugin installed"
    echo ""
    echo "Next: run 'just obsidian' to open Obsidian with debugging enabled"

# Quick rebuild (for rapid iteration)
reinstall: build
    #!/usr/bin/env bash
    VAULT_ARG="{{test_vault}}"
    VAULT="\${VAULT_ARG/#\\~/$HOME}"
    mkdir -p "$VAULT/.obsidian/plugins/{{plugin_name}}"
    cp main.js "$VAULT/.obsidian/plugins/{{plugin_name}}/"
    echo "âœ“ Plugin updated - reload Obsidian (Cmd+R) to see changes"

# Clean build artifacts
clean:
    rm -rf main.js main.js.map lib/ node_modules/.cache/
    @echo "âœ“ Build artifacts cleaned"

# Launch Obsidian with Chrome DevTools Protocol debugging
obsidian:
    #!/usr/bin/env bash
    set -euo pipefail
    DEBUG_PORT="{{debug_port}}"

    # Kill any existing Obsidian with debug port
    pkill -f "Obsidian.*--remote-debugging-port" 2>/dev/null || true
    sleep 1

    # Launch with remote debugging
    /Applications/Obsidian.app/Contents/MacOS/Obsidian --remote-debugging-port="$DEBUG_PORT" > /dev/null 2>&1 &

    echo "Launching Obsidian with CDP on port $DEBUG_PORT..."

    # Wait for debug port
    for i in {1..10}; do
        if curl -s "http://localhost:$DEBUG_PORT/json/version" > /dev/null 2>&1; then
            echo "âœ“ Obsidian ready for debugging at http://localhost:$DEBUG_PORT"
            exit 0
        fi
        sleep 1
    done

    echo "âš  Warning: Debug port not responding after 10s"
    exit 1
`;
}

function generateMcpJson(): string {
  return JSON.stringify(
    {
      mcpServers: {
        "chromedevtools/chrome-devtools-mcp": {
          type: "stdio",
          command: "npx",
          args: [
            "-y",
            "chrome-devtools-mcp@latest",
            "--browserUrl",
            "http://127.0.0.1:9222",
          ],
          env: {},
        },
      },
    },
    null,
    2
  );
}

function generateClaudeMd(config: PluginConfig): string {
  return `# ${config.name} - Claude Code Instructions

## Project Overview

${config.description}

## Development Workflow

### Quick Start

1. Install dependencies:
   \`\`\`bash
   just install
   \`\`\`

2. Build and install to test vault:
   \`\`\`bash
   just setup
   \`\`\`

3. Start development mode (auto-rebuild on changes):
   \`\`\`bash
   just dev
   \`\`\`

4. Launch Obsidian with debugging:
   \`\`\`bash
   just obsidian
   \`\`\`

### Chrome DevTools Protocol Debugging

This project uses the Chrome DevTools MCP server to connect to Obsidian for debugging.

#### MCP Tools Available

- \`list_pages\` - List open pages/windows
- \`select_page\` - Select a page to work with
- \`take_snapshot\` - Get a text snapshot of the UI (a11y tree)
- \`take_screenshot\` - Capture the current view
- \`click\`, \`fill\`, \`hover\` - Interact with UI elements
- \`evaluate_script\` - Run JavaScript in Obsidian's context
- \`list_console_messages\` - View console output
- \`list_network_requests\` - Monitor network activity

#### Typical Debugging Workflow

1. Run \`just obsidian\` to start Obsidian with debugging
2. Use \`list_pages\` to see available pages (usually \`app://obsidian.md/index.html\`)
3. Use \`take_snapshot\` to get a text representation of the current UI
4. Interact with elements using their \`uid\` from the snapshot
5. Use \`evaluate_script\` to run JavaScript for complex operations

### Project Structure

\`\`\`
${config.id}/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.ts          # Plugin entry point
${config.hasSettings ? "â”‚   â”œâ”€â”€ settings.ts      # Settings tab\n" : ""}${config.hasSidebar ? "â”‚   â””â”€â”€ view.ts          # Sidebar view\n" : ""}â”œâ”€â”€ manifest.json        # Plugin manifest
â”œâ”€â”€ package.json         # Dependencies
â”œâ”€â”€ justfile             # Task runner
â”œâ”€â”€ .mcp.json            # MCP server config
â””â”€â”€ CLAUDE.md            # AI instructions (this file)
\`\`\`

### Key Files

- **src/main.ts**: Main plugin class with \`onload()\` and \`onunload()\` lifecycle methods
${config.hasSettings ? "- **src/settings.ts**: Settings interface and settings tab UI\n" : ""}${config.hasSidebar ? "- **src/view.ts**: Custom sidebar view implementation\n" : ""}- **manifest.json**: Plugin metadata (id, name, version, description)

## Obsidian API Reference

### Common Patterns

#### Reading a file:
\`\`\`typescript
const content = await this.app.vault.read(file);
\`\`\`

#### Creating a file:
\`\`\`typescript
await this.app.vault.create("path/to/file.md", content);
\`\`\`

#### Getting active file:
\`\`\`typescript
const activeFile = this.app.workspace.getActiveFile();
\`\`\`

#### Adding a command:
\`\`\`typescript
this.addCommand({
  id: "command-id",
  name: "Command Name",
  callback: () => { /* ... */ },
});
\`\`\`

#### Adding a ribbon icon:
\`\`\`typescript
this.addRibbonIcon("icon-name", "Tooltip", (evt) => { /* ... */ });
\`\`\`

### Important Notes

- The debug port (9222) must be free before launching Obsidian
- Only one Obsidian instance with debugging can run at a time
- Use \`console.log()\` for debugging - view with \`list_console_messages\` MCP tool
- Hot reload plugin will auto-reload on file changes

## Features

${config.features.map((f) => `- ${f}`).join("\n")}
`;
}

function generateGitignore(): string {
  return `# Build artifacts
main.js
main.js.map
lib/

# Dependencies
node_modules/

# IDE
.idea/
.vscode/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Obsidian
data.json
`;
}

function generateStylesCss(): string {
  return `/* ${new Date().toISOString().split("T")[0]} - Plugin styles */

/* Add your styles here */
`;
}

function generateVersionsJson(): string {
  return JSON.stringify(
    {
      "0.1.0": "0.15.0",
    },
    null,
    2
  );
}

function generateVersionBumpMjs(): string {
  return `import { readFileSync, writeFileSync } from "fs";

const targetVersion = process.env.npm_package_version;

// read minAppVersion from manifest.json and bump version to target version
let manifest = JSON.parse(readFileSync("manifest.json", "utf8"));
const { minAppVersion } = manifest;
manifest.version = targetVersion;
writeFileSync("manifest.json", JSON.stringify(manifest, null, "\\t"));

// update versions.json with target version and minAppVersion from manifest.json
let versions = JSON.parse(readFileSync("versions.json", "utf8"));
versions[targetVersion] = minAppVersion;
writeFileSync("versions.json", JSON.stringify(versions, null, "\\t"));
`;
}

function generateReadme(config: PluginConfig): string {
  return `# ${config.name}

${config.description}

## Features

${config.features.map((f) => `- ${f}`).join("\n")}

## Installation

### From Obsidian Community Plugins (Coming Soon)

1. Open Obsidian Settings
2. Go to Community Plugins
3. Search for "${config.name}"
4. Click Install

### Manual Installation

1. Download the latest release
2. Extract to your vault's \`.obsidian/plugins/${config.id}/\` folder
3. Enable the plugin in Obsidian settings

## Development

This plugin includes AI-assisted development tooling:

\`\`\`bash
# Install dependencies
just install

# Build and setup test vault
just setup

# Start development mode
just dev

# Launch Obsidian with debugging
just obsidian
\`\`\`

See [CLAUDE.md](./CLAUDE.md) for detailed development instructions.

## License

MIT
`;
}

// ============================================================================
// UTILITIES
// ============================================================================

function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("");
}

function slugify(str: string): string {
  return str
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "");
}

function extractFeaturesFromDescription(description: string): string[] {
  const features: string[] = [];

  // Common feature patterns
  const patterns = [
    { regex: /search|find|query/i, feature: "Search and query functionality" },
    {
      regex: /sync|synchronize|backup/i,
      feature: "Synchronization capabilities",
    },
    { regex: /template|scaffold|generate/i, feature: "Template generation" },
    { regex: /export|import/i, feature: "Import/export support" },
    { regex: /tag|categorize|organize/i, feature: "Organization tools" },
    {
      regex: /reminder|notification|alert/i,
      feature: "Notifications and reminders",
    },
    {
      regex: /calendar|schedule|date/i,
      feature: "Calendar/scheduling integration",
    },
    {
      regex: /graph|visualize|chart/i,
      feature: "Data visualization",
    },
    { regex: /ai|gpt|llm|automate/i, feature: "AI-powered automation" },
    { regex: /markdown|format|style/i, feature: "Markdown enhancement" },
  ];

  for (const { regex, feature } of patterns) {
    if (regex.test(description)) {
      features.push(feature);
    }
  }

  // Always include these basics
  if (features.length === 0) {
    features.push("Core plugin functionality");
  }

  return features;
}

// ============================================================================
// WIZARD
// ============================================================================

async function runWizard(): Promise<PluginConfig> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  const question = (prompt: string): Promise<string> => {
    return new Promise((resolve) => {
      rl.question(prompt, resolve);
    });
  };

  const yesNo = async (prompt: string, defaultYes = true): Promise<boolean> => {
    const suffix = defaultYes ? " [Y/n]: " : " [y/N]: ";
    const answer = await question(prompt + suffix);
    if (answer.trim() === "") return defaultYes;
    return answer.toLowerCase().startsWith("y");
  };

  console.log("\nðŸª„ Obsidian Plugin Scaffold Generator\n");
  console.log("This wizard will create an AI-ready Obsidian plugin template.\n");

  // Basic info
  const name = await question("Plugin name (e.g., 'My Awesome Plugin'): ");
  const id =
    (await question(`Plugin ID [${slugify(name)}]: `)) || slugify(name);
  const description = await question("Description: ");
  const author = (await question("Author name [Anonymous]: ")) || "Anonymous";

  // Features
  console.log("\nðŸ“¦ Plugin Features:\n");
  const hasSettings = await yesNo("Include settings tab?");
  const hasCommands = await yesNo("Include commands?");
  const hasSidebar = await yesNo("Include sidebar view?");
  const hasRibbon = await yesNo("Include ribbon icon?");

  // Output
  const defaultOutput = path.join(process.cwd(), id);
  const outputDir =
    (await question(`Output directory [${defaultOutput}]: `)) || defaultOutput;

  rl.close();

  const features = extractFeaturesFromDescription(description);
  if (hasSettings) features.push("Configurable settings");
  if (hasCommands) features.push("Command palette integration");
  if (hasSidebar) features.push("Custom sidebar view");
  if (hasRibbon) features.push("Ribbon icon quick access");

  return {
    id,
    name,
    description,
    author,
    features,
    hasSettings,
    hasCommands,
    hasSidebar,
    hasRibbon,
    outputDir,
  };
}

// ============================================================================
// GENERATOR
// ============================================================================

function generatePlugin(config: PluginConfig): void {
  const { outputDir } = config;

  // Create directory structure
  const dirs = [outputDir, path.join(outputDir, "src")];
  for (const dir of dirs) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }

  // Write files
  const files: Array<{ path: string; content: string }> = [
    { path: "manifest.json", content: generateManifest(config) },
    { path: "package.json", content: generatePackageJson(config) },
    { path: "tsconfig.json", content: generateTsConfig() },
    { path: "esbuild.config.mjs", content: generateEsbuildConfig(config) },
    { path: "justfile", content: generateJustfile(config) },
    { path: ".mcp.json", content: generateMcpJson() },
    { path: "CLAUDE.md", content: generateClaudeMd(config) },
    { path: ".gitignore", content: generateGitignore() },
    { path: "styles.css", content: generateStylesCss() },
    { path: "versions.json", content: generateVersionsJson() },
    { path: "version-bump.mjs", content: generateVersionBumpMjs() },
    { path: "README.md", content: generateReadme(config) },
    { path: "src/main.ts", content: generateMainTs(config) },
  ];

  if (config.hasSettings) {
    files.push({
      path: "src/settings.ts",
      content: generateSettingsTs(config),
    });
  }

  if (config.hasSidebar) {
    files.push({ path: "src/view.ts", content: generateViewTs(config) });
  }

  for (const file of files) {
    const fullPath = path.join(outputDir, file.path);
    fs.writeFileSync(fullPath, file.content);
    console.log(`  âœ“ ${file.path}`);
  }
}

// ============================================================================
// CLI
// ============================================================================

async function main() {
  const args = process.argv.slice(2);

  let config: PluginConfig;

  if (args.includes("--wizard") || args.includes("-w") || args.length === 0) {
    // Interactive wizard mode
    config = await runWizard();
  } else if (args.length >= 2) {
    // Quick mode: create-obsidian-plugin "plugin-id" "Description"
    const id = args[0];
    const description = args.slice(1).join(" ");
    const name = id
      .split("-")
      .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
      .join(" ");

    config = {
      id: slugify(id),
      name,
      description,
      author: process.env.USER || "Anonymous",
      features: extractFeaturesFromDescription(description),
      hasSettings: true,
      hasCommands: true,
      hasSidebar: false,
      hasRibbon: true,
      outputDir: path.join(process.cwd(), slugify(id)),
    };
  } else {
    console.error("Usage:");
    console.error(
      "  npx tsx bin/create-obsidian-plugin.ts --wizard              # Interactive mode"
    );
    console.error(
      '  npx tsx bin/create-obsidian-plugin.ts "id" "description"    # Quick mode'
    );
    process.exit(1);
  }

  console.log("\nðŸ“ Creating plugin scaffold...\n");
  generatePlugin(config);

  console.log(`
âœ¨ Plugin scaffold created!

Next steps:
  cd ${config.outputDir}
  just install
  just setup
  just dev

Happy coding! ðŸš€
`);
}

main().catch((err) => {
  console.error("Error:", err);
  process.exit(1);
});
